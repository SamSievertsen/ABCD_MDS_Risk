---
title: "2. BD Mixed-Effects Logit"
author: "Sam A. Sievertsen"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: false
    df_print: paged
params:
  repo: !r getwd()
  data_dir: "data/data_processed/analysis_datasets/"
  out_dir: "results/main_analysis/2_bd_mixed_logit"
  bd_panel_rds: "bd_panel_k2_robust.rds"
  bd_panel_csv: "bd_panel_k2_robust.csv"
  outcomes: !r c("bipolar_I","bipolar_II","bd_nos","any_bsd")
  response_var: "status"
  link_primary: "logit"
  wave_ref: "ses-02A"
  ages_pred: !r NULL
  show_code: !r FALSE
  gamm_basis: "tp"
  k_age: 6
  mgcv_gamma: 1.6
  bam_discrete: !r TRUE
  do_gamm: !r FALSE
  do_gee_interaction: !r TRUE
---

<--
Notes
- Single age term for all models: age_wave_gmc
- GAMM curves are predicted over raw age (age_wave) by back-transforming the centered grid
- Ladder: GLMM, GLMM+baseline, glmmTMB, GEE (EXC primary, AR1 sensitivity), GAMM (bam w/ s(participant_id, bs="re"))
- Outputs: CSVs, RDS fits, forest plots (GEE OR by wave), GAMM age curves; all embedded in HTML
-->

```{r setup, message=FALSE, warning=FALSE, echo = params$show_code}
knitr::opts_chunk$set(echo = params$show_code, message = FALSE, warning = FALSE, fig.align="center")
Sys.setenv(MKL_NUM_THREADS = "1", OPENBLAS_NUM_THREADS = "1", BLIS_NUM_THREADS = "1")
N_CORES <- as.integer(Sys.getenv("SLURM_CPUS_PER_TASK", Sys.getenv("OMP_NUM_THREADS", "4")))
options(mc.cores = N_CORES)
message(glue::glue("Threads -> OMP:{Sys.getenv('OMP_NUM_THREADS')}  MKL:{Sys.getenv('MKL_NUM_THREADS')}  OPENBLAS:{Sys.getenv('OPENBLAS_NUM_THREADS')}  BLIS:{Sys.getenv('BLIS_NUM_THREADS')}  |  bam nthreads:{N_CORES}"))
options(width = 120, pillar.sigfig = 3, dplyr.summarise.inform = FALSE)
suppressPackageStartupMessages({
  library(dplyr)
  library(forcats)
  library(ggplot2)
  library(tidyr)
  library(stringr)
  library(data.table)
  library(lme4)
  library(glmmTMB)
  library(geepack)
  library(mgcv)
  library(broom)
  library(broom.mixed)
  library(pROC)
  library(emmeans)
  library(janitor)
  library(glue)
  library(readr)
  library(performance)
  library(yardstick)
  library(clubSandwich)
})
theme_set(theme_bw())
```

# Data
```{r data-load}
REPO      <- params$repo
DATA_DIR  <- file.path(REPO, params$data_dir)
OUT_DIR   <- file.path(REPO, params$out_dir)
dir.create(file.path(OUT_DIR, "csv"), recursive = TRUE, showWarnings = FALSE)
dir.create(file.path(OUT_DIR, "figures"), recursive = TRUE, showWarnings = FALSE)
dir.create(file.path(OUT_DIR, "rds"), recursive = TRUE, showWarnings = FALSE)
dir.create(file.path(OUT_DIR, "pred_csv"), recursive = TRUE, showWarnings = FALSE)

rds_path <- file.path(DATA_DIR, params$bd_panel_rds)
csv_path <- file.path(DATA_DIR, params$bd_panel_csv)

if (file.exists(rds_path)) {
  bd <- readRDS(rds_path)
} else {
  bd <- readr::read_csv(csv_path, show_col_types = FALSE)
}

# Standardize
bd <- bd %>%
  mutate(
    wave = factor(wave, levels = c("ses-02A","ses-04A","ses-06A"), ordered = TRUE),
    cluster = factor(cluster, levels = c("C2","C1")),
    sex = factor(sex, levels = c("Female","Male")),
    participant_id = as.factor(participant_id),
    site_factor = as.factor(site_factor),
    family_id = as.factor(family_id),
    baseline_status_bd = as.factor(baseline_status_bd)
  )

stopifnot(all(c("outcome","status","age_wave","age_wave_gmc","cluster","wave","sex","participant_id") %in% names(bd)))

# Helper to select baseline variable
pick_baseline_col <- function(df, outcome_name) {
  cand <- paste0("baseline_status_", outcome_name)
  if (cand %in% names(df)) return(cand)
  if ("baseline_status_bd" %in% names(df)) return("baseline_status_bd")
  return(NULL)
}

# Age grid for plotting GAMM: we will predict on raw age (age_wave) but models use age_wave_gmc;
# so we build grid on age_wave, then compute the centered version inside each outcome loop based on that group's grand mean.
if (!is.null(params$ages_pred)) {
  age_grid_raw <- sort(unique(params$ages_pred))
} else {
  rng <- range(bd$age_wave, na.rm = TRUE)
  age_grid_raw <- seq(floor(rng[1]), ceiling(rng[2]), by = 0.1)
}
```

# Utilities
```{r utils}
# Robust CI column extractor for emmeans
extract_emm_ci_cols <- function(tb) {
  nm <- names(tb)
  if (all(c('lower.CL','upper.CL') %in% nm)) return(list(low = tb$lower.CL, high = tb$upper.CL))
  if (all(c('asymp.LCL','asymp.UCL') %in% nm)) return(list(low = tb$asymp.LCL, high = tb$asymp.UCL))
  if (all(c('LCL','UCL') %in% nm)) return(list(low = tb$LCL, high = tb$UCL))
  if (all(c('lower.HPD','upper.HPD') %in% nm)) return(list(low = tb$lower.HPD, high = tb$upper.HPD))
  list(low = rep(NA_real_, nrow(tb)), high = rep(NA_real_, nrow(tb)))
}

# AUC (QC only)
safe_predict <- function(mod, newdata = NULL, type = "response") {
  pr <- try({
    if (inherits(mod, "merMod")) predict(mod, newdata = newdata, type = type, re.form = NA) else
    if (inherits(mod, "glmmTMB")) predict(mod, newdata = newdata, type = type, re.form = NA) else
    predict(mod, newdata = newdata, type = type)
  }, silent = TRUE)
  if (inherits(pr, "try-error")) {
    if (is.null(newdata)) return(rep(NA_real_, length(fitted(mod)))) else return(rep(NA_real_, nrow(newdata)))
  } else as.numeric(pr)
}

auc_qc <- function(fit, df) {
  p <- safe_predict(fit, df, "response")
  ro <- try(pROC::roc(df$status, p, quiet = TRUE), silent = TRUE)
  if (inherits(ro, "try-error")) NA_real_ else as.numeric(pROC::auc(ro))
}

dispersion_check <- function(mod) {
  r <- try(residuals(mod, type = "pearson"), silent = TRUE)
  df <- try(df.residual(mod),           silent = TRUE)
  if (inherits(r,"try-error") || inherits(df,"try-error") || is.null(df) || df <= 0) return(NA_real_)
  sum(r^2, na.rm = TRUE) / df
}

# Extract cluster main effect (OR + CI + p)
extract_cluster <- function(fit) {
  out <- tibble::tibble(term = "clusterC1", OR = NA_real_, CI_low = NA_real_, CI_high = NA_real_, p = NA_real_)
  if (inherits(fit, "merMod")) {
    sm <- coef(summary(fit)); if (!"clusterC1" %in% rownames(sm)) return(out)
    b <- sm["clusterC1","Estimate"]; se <- sm["clusterC1","Std. Error"]; z <- b/se; p <- 2*pnorm(abs(z), lower.tail = FALSE)
    tibble::tibble(term="clusterC1", OR = exp(b), CI_low = exp(b-1.96*se), CI_high = exp(b+1.96*se), p = p)
  } else if (inherits(fit, "glmmTMB")) {
    sm <- summary(fit)$coefficients$cond; if (is.null(sm) || !"clusterC1" %in% rownames(sm)) return(out)
    b <- sm["clusterC1","Estimate"]; se <- sm["clusterC1","Std. Error"]; z <- b/se; p <- 2*pnorm(abs(z), lower.tail = FALSE)
    tibble::tibble(term="clusterC1", OR = exp(b), CI_low = exp(b-1.96*se), CI_high = exp(b+1.96*se), p = p)
  } else if ("geeglm" %in% class(fit)) {
    sm <- summary(fit)$coefficients; rn <- rownames(sm); if (!"clusterC1" %in% rn) return(out)
    b <- sm["clusterC1","Estimate"]; se <- sm["clusterC1","Robust S.E."]; z <- b/se; p <- 2*pnorm(abs(z), lower.tail = FALSE)
    tibble::tibble(term="clusterC1", OR = exp(b), CI_low = exp(b-1.96*se), CI_high = exp(b+1.96*se), p = p)
  } else out
}

# EMMEANS: cluster C1 vs C2 OR by wave
or_by_wave_emm <- function(fit, df, model, outcome) {
  if (inherits(fit, "try-error")) return(NULL)
  emm <- try(emmeans(fit, ~ cluster | wave, type = "link"), silent = TRUE)
  if (inherits(emm, "try-error")) return(NULL)
  sm  <- try(contrast(emm, method = "revpairwise") %>% summary(infer = TRUE), silent = TRUE)
  if (inherits(sm, "try-error")) return(NULL)
  tb <- as_tibble(sm)
  ci <- extract_emm_ci_cols(tb)
  tibble::tibble(outcome = outcome, model = model, wave = as.character(tb$wave),
         OR = exp(tb$estimate), CI_low = exp(ci$low), CI_high = exp(ci$high))
}

# Wave labels with C1 n and median age (overall)
wave_labels_with_sample_age <- function(df) {
  labs <- df %>%
    group_by(wave) %>%
    summarize(
      n_C1 = sum(cluster == "C1", na.rm = TRUE),
      med_age_all = median(age_wave, na.rm = TRUE), .groups="drop"
    ) %>%
    mutate(lab = glue("{wave}\nC1 n={n_C1}, med age(all)={round(med_age_all,1)}")) %>%
    select(wave = wave, lab)
  labs
}

# Fitters
fit_glmm <- function(df, base_col) {
  rhs <- paste("cluster + wave + sex + age_wave_gmc", base_col, sep = " + ")
  fml <- as.formula(glue("status ~ {rhs} + (1|participant_id)"))
  ctrl <- glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 2e5))
  try(glmer(fml, data = df, family = binomial(link = params$link_primary), control = ctrl, nAGQ = 0), silent = TRUE)
}
fit_glmmtmb <- function(df, base_col) {
  rhs <- paste("cluster + wave + sex + age_wave_gmc", base_col, sep = " + ")
  fml <- as.formula(glue("status ~ {rhs} + (1|participant_id)"))
  try(glmmTMB(fml, data = df, family = binomial(link = params$link_primary)), silent = TRUE)
}

fit_gee <- function(df, corstr = "exchangeable", link = "logit", interaction = FALSE) {
  fml <- if (isTRUE(interaction)) {
    as.formula(status ~ cluster * wave + sex + baseline_status_bd + age_wave_gmc)
  } else {
    as.formula(status ~ cluster + wave + sex + baseline_status_bd + age_wave_gmc)
  }
  try(
    geeglm(fml, id = participant_id, data = df,
           family = binomial(link = link),
           corstr = corstr, std.err = "san.se"),
    silent = TRUE
  )
}

fit_gamm <- function(df) {
  fml <- as.formula(glue::glue(
  "status ~ cluster + wave + sex + s(age_wave_gmc, cluster, bs = 'fs', k = {params$k_age}) + s(participant_id, bs = 're')"))
  try(mgcv::bam(
    fml, data = df, family = binomial(link = params$link_primary),
    discrete = isTRUE(params$bam_discrete), nthreads = N_CORES, method = "fREML",
    select = TRUE, gamma = params$mgcv_gamma
  ), silent = TRUE)
}

# Ensure list column has a 1-row tibble for cluster stats
ensure_cluster_row <- function(x) {
  if (inherits(x, "try-error") || is.null(x) || !nrow(x)) return(tibble::tibble(term="clusterC1", OR=NA_real_, CI_low=NA_real_, CI_high=NA_real_, p=NA_real_))
  x %>% dplyr::filter(term == "clusterC1") %>%
    dplyr::select(term, OR, CI_low, CI_high, p) %>%
    { if (!nrow(.)) tibble::tibble(term="clusterC1", OR=NA_real_, CI_low=NA_real_, CI_high=NA_real_, p=NA_real_) else . }
}

tidy_or <- function(x, term_keep = NULL) {
  # 1) Tidy the model safely
  tx <- tryCatch({
    if (inherits(x, "merMod")) {
      broom.mixed::tidy(x, effects = "fixed")
    } else if (inherits(x, "glmmTMB")) {
      broom.mixed::tidy(x, effects = "fixed") %>%
        dplyr::filter(.data$component %in% c("cond", NA))
    } else {
      broom::tidy(x)
    }
  }, error = function(e) tibble::tibble())

  if (!nrow(tx)) {
    return(tibble::tibble(term = character(), estimate = numeric(),
                          OR = numeric(), CI_low = numeric(), CI_high = numeric()))
  }

  # 2) Pick a standard error column robustly (no NULLs)
  se_name <- intersect(
    c("std.error", "Std. Error", "SE", "robust.se", "robust.SE", "Robust S.E.", "robust_se"),
    names(tx)
  )
  se <- if (length(se_name)) {
    as.numeric(tx[[se_name[1]]])
  } else {
    rep(NA_real_, nrow(tx))
  }

  # 3) Optional term filter
  if (!is.null(term_keep)) {
    tx <- dplyr::filter(tx, stringr::str_detect(.data$term, term_keep))
  }

  # 4) Add OR + Wald CI on the logit scale
  dplyr::mutate(
    tx,
    OR      = exp(.data$estimate),
    CI_low  = exp(.data$estimate - 1.96 * se),
    CI_high = exp(.data$estimate + 1.96 * se)
  )
}
```

# Per-outcome modeling
```{r main, message=FALSE}
OUTS <- params$outcomes
summary_rows <- list()

for (oc in OUTS) {
  df_o <- bd %>% filter(outcome == oc) %>% drop_na(status, cluster, wave, sex, participant_id, age_wave, age_wave_gmc)
  if (!nrow(df_o)) next
  base_col <- pick_baseline_col(df_o, oc)
  base_col <- ifelse(is.null(base_col), "1", base_col)

  # Save grand mean of raw age for plotting back-transform
  gm_age <- mean(df_o$age_wave, na.rm = TRUE)
  
  # Per-outcome, trimmed age grid to avoid extreme tails (reduces wiggles)
  rng <- stats::quantile(df_o$age_wave, probs = c(0.05, 0.95), na.rm = TRUE)
  age_grid <- seq(floor(rng[1]), ceiling(rng[2]), by = 0.1)

  # Fits
  glmm_fit   <- fit_glmm(df_o, base_col)
  glmmb_fit  <- if (base_col != "1") fit_glmm(df_o, base_col) else glmm_fit 
  tmb_fit    <- fit_glmmtmb(df_o, base_col)
  gee_exc <- fit_gee(df_o, corstr = "exchangeable", link = params$link_primary, interaction = FALSE)
  gee_ar1 <- fit_gee(df_o, corstr = "ar1",           link = params$link_primary, interaction = FALSE)
  gee_ok  <- !inherits(gee_exc,"try-error")
  ar1_ok  <- !inherits(gee_ar1,"try-error")
  gee_exc_int <- if (isTRUE(params$do_gee_interaction)) fit_gee(df_o, "exchangeable", params$link_primary, interaction = TRUE) else structure("off", class="try-error")
  gee_ar1_int <- if (isTRUE(params$do_gee_interaction)) fit_gee(df_o, "ar1", params$link_primary, interaction = TRUE) else structure("off", class="try-error")
  gee_int_ok  <- !inherits(gee_exc_int,"try-error")
  ar1_int_ok  <- !inherits(gee_ar1_int,"try-error")
  gam_fit <- if (isTRUE(params$do_gamm)) fit_gamm(df_o) else structure("off", class = "try-error")

  # Save RDS
  try(saveRDS(glmm_fit,  file.path(OUT_DIR, "rds", glue("{oc}_GLMM.rds")), compress="xz"), silent=TRUE)
  if (base_col != "1") try(saveRDS(glmmb_fit, file.path(OUT_DIR, "rds", glue("{oc}_GLMM_with_baseline.rds")), compress="xz"), silent=TRUE)
  try(saveRDS(tmb_fit,   file.path(OUT_DIR, "rds", glue("{oc}_glmmTMB.rds")), compress="xz"), silent=TRUE)
  if (gee_ok) {
    try(saveRDS(gee_exc, file.path(OUT_DIR, "rds", glue("{oc}_GEE_EXC.rds")), compress="xz"), silent=TRUE)
    gee_tbl <- tidy_or(gee_exc)
    gee_ex_pair <- or_by_wave_emm(gee_exc, df_o, "GEE_EXC", oc)
    if (nrow(gee_tbl))     write_csv(gee_tbl %>% mutate(outcome = oc), file.path(OUT_DIR, "csv", glue("{oc}_GEE_EXC_fixed_ORs.csv")))
    if (!is.null(gee_ex_pair)) write_csv(gee_ex_pair, file.path(OUT_DIR, "csv", glue("{oc}_GEE_EXC_cluster_OR_by_wave.csv")))
  }
  if (ar1_ok) {
    try(saveRDS(gee_ar1, file.path(OUT_DIR, "rds", glue("{oc}_GEE_AR1.rds")), compress="xz"), silent=TRUE)
    ar1_tbl     <- tidy_or(gee_ar1)
    gee_ar_pair <- or_by_wave_emm(gee_ar1, df_o, "GEE_AR1", oc)
    if (nrow(ar1_tbl))     write_csv(ar1_tbl %>% mutate(outcome = oc), file.path(OUT_DIR, "csv", glue("{oc}_GEE_AR1_fixed_ORs.csv")))
    if (!is.null(gee_ar_pair)) write_csv(gee_ar_pair, file.path(OUT_DIR, "csv", glue("{oc}_GEE_AR1_cluster_OR_by_wave.csv")))
  }
  
  if (gee_int_ok) {
    try(saveRDS(gee_exc_int, file.path(OUT_DIR, "rds", glue("{oc}_GEE_EXC_INT.rds")), compress="xz"), silent=TRUE)
    gee_tbl_int     <- tidy_or(gee_exc_int)
    gee_ex_pair_int <- or_by_wave_emm(gee_exc_int, df_o, "GEE_EXC_INT", oc)
    if (nrow(gee_tbl_int))     write_csv(gee_tbl_int %>% mutate(outcome = oc), file.path(OUT_DIR, "csv", glue("{oc}_GEE_EXC_INT_fixed_ORs.csv")))
    if (!is.null(gee_ex_pair_int)) write_csv(gee_ex_pair_int, file.path(OUT_DIR, "csv", glue("{oc}_GEE_EXC_INT_cluster_OR_by_wave.csv")))
  }
  if (ar1_int_ok) {
    try(saveRDS(gee_ar1_int, file.path(OUT_DIR, "rds", glue("{oc}_GEE_AR1_INT.rds")), compress="xz"), silent=TRUE)
    ar1_tbl_int     <- tidy_or(gee_ar1_int)
    gee_ar_pair_int <- or_by_wave_emm(gee_ar1_int, df_o, "GEE_AR1_INT", oc)
    if (nrow(ar1_tbl_int))     write_csv(ar1_tbl_int %>% mutate(outcome = oc), file.path(OUT_DIR, "csv", glue("{oc}_GEE_AR1_INT_fixed_ORs.csv")))
    if (!is.null(gee_ar_pair_int)) write_csv(gee_ar_pair_int, file.path(OUT_DIR, "csv", glue("{oc}_GEE_AR1_INT_cluster_OR_by_wave.csv")))
  }

  glmm_tbl  <- if (!inherits(glmm_fit,"try-error"))  tidy_or(glmm_fit)  else tibble()
  glmmb_tbl <- if (base_col!="1" && !inherits(glmmb_fit,"try-error")) tidy_or(glmmb_fit) else tibble()
  tmb_tbl   <- if (!inherits(tmb_fit,"try-error"))   tidy_or(tmb_fit)   else tibble()
  gee_tbl   <- if (!inherits(gee_exc,"try-error"))   tidy_or(gee_exc)   else tibble()
  ar1_tbl   <- if (!inherits(gee_ar1,"try-error"))   tidy_or(gee_ar1)   else tibble()

  # Write CSVs
  write_csv(glmm_tbl %>% mutate(outcome = oc),  file.path(OUT_DIR, "csv", glue("{oc}_GLMM_fixed_ORs.csv")))
  if (nrow(glmmb_tbl)) write_csv(glmmb_tbl %>% mutate(outcome = oc), file.path(OUT_DIR, "csv", glue("{oc}_GLMM_with_baseline_fixed_ORs.csv")))
  write_csv(tmb_tbl  %>% mutate(outcome = oc),  file.path(OUT_DIR, "csv", glue("{oc}_glmmTMB_fixed_ORs.csv")))
  if (nrow(gee_tbl)) write_csv(gee_tbl %>% mutate(outcome = oc),     file.path(OUT_DIR, "csv", glue("{oc}_GEE_EXC_fixed_ORs.csv")))
  if (nrow(ar1_tbl)) write_csv(ar1_tbl %>% mutate(outcome = oc),     file.path(OUT_DIR, "csv", glue("{oc}_GEE_AR1_fixed_ORs.csv")))

  # OR by wave via emmeans
  gee_ex_pair <- or_by_wave_emm(gee_exc, df_o, "GEE_EXC", oc)
  gee_ar_pair <- or_by_wave_emm(gee_ar1, df_o, "GEE_AR1", oc)
  if (!is.null(gee_ex_pair)) write_csv(gee_ex_pair, file.path(OUT_DIR, "csv", glue("{oc}_GEE_EXC_cluster_OR_by_wave.csv")))
  if (!is.null(gee_ar_pair)) write_csv(gee_ar_pair, file.path(OUT_DIR, "csv", glue("{oc}_GEE_AR1_cluster_OR_by_wave.csv")))

  # --- Forest plot: additive (primary) ---
  if (gee_ok && !is.null(gee_ex_pair) && nrow(gee_ex_pair)) {
    labs <- wave_labels_with_sample_age(df_o)  
    g <- gee_ex_pair %>%
      mutate(wave = as.character(wave)) %>%
      left_join(labs %>% mutate(wave = as.character(wave)), by = "wave") %>%
      mutate(lab = factor(lab, levels = unique(lab))) %>%
      ggplot(aes(x = lab, y = OR, ymin = CI_low, ymax = CI_high)) +
      geom_hline(yintercept = 1, linetype = 2) +
      geom_pointrange(position = position_dodge(width = 0.2)) +
      labs(title = glue("{oc}: Cluster C1 vs C2 OR by wave (GEE EXC, additive)"),
         y = "Odds ratio", x = "Wave (n_C1; median age)") +
      theme(panel.grid.minor = element_blank())
    ggsave(file.path(OUT_DIR, "figures", glue("{oc}_GEE_EXC_cluster_OR_by_wave.png")),
         g, width = 7.2, height = 4.6, dpi = 300)
  }

  # --- Forest plot: interaction model ---
  if (gee_int_ok && !is.null(gee_ex_pair_int) && nrow(gee_ex_pair_int)) {
    labs <- wave_labels_with_sample_age(df_o)
    g_int <- gee_ex_pair_int %>%
      mutate(wave = as.character(wave)) %>%
      left_join(labs %>% mutate(wave = as.character(wave)), by = "wave") %>%
      mutate(lab = factor(lab, levels = unique(lab))) %>%
      ggplot(aes(x = lab, y = OR, ymin = CI_low, ymax = CI_high)) +
      geom_hline(yintercept = 1, linetype = 2) +
      geom_pointrange(position = position_dodge(width = 0.2)) +
      labs(title = glue("{oc}: Cluster C1 vs C2 OR by wave (GEE EXC, cluster x wave)"),
         y = "Odds ratio", x = "Wave (n_C1; median age)") +
      theme(panel.grid.minor = element_blank())
    ggsave(file.path(OUT_DIR, "figures", glue("{oc}_GEE_EXC_INT_cluster_OR_by_wave.png")),
         g_int, width = 7.2, height = 4.6, dpi = 300)
  }

  # GAMM predictions & plot (if enabled)
  if (!inherits(gam_fit,"try-error")) {

    # Predict along the per-outcome trimmed age grid; fix wave/sex for a clean age curve
    newdat <- tidyr::crossing(
      age_wave = age_grid,
      cluster  = factor(c("C2","C1"), levels = c("C2","C1")),
      wave     = factor(params$wave_ref, levels = levels(df_o$wave), ordered = is.ordered(df_o$wave)),
      sex      = factor("Female", levels = levels(df_o$sex))) %>%
      mutate(

        # center age using the outcome-specific grand mean from the fit
        age_wave_gmc   = age_wave - gm_age,

        # provide a valid subject level (we'll exclude this RE in prediction)
        participant_id = factor(levels(df_o$participant_id)[1], levels = levels(df_o$participant_id)))

    # Exclude the subject random effect so curves are marginal over participants
    pr <- try(
      predict(gam_fit, newdata = newdat, type = "link", se.fit = TRUE, exclude = "s(participant_id)"),
      silent = TRUE)

    if (!inherits(pr,"try-error")) {
      pred <- newdat %>%
        mutate(
          eta = as.numeric(pr$fit),
          se  = as.numeric(pr$se.fit),
          p   = plogis(eta),
          lo  = plogis(eta - 1.96*se),
          hi  = plogis(eta + 1.96*se),
          outcome      = oc,
          age_var_used = "age_wave_gmc",
          gamm_engine  = "bam")

      # Save preds
      write_csv(pred, file.path(OUT_DIR, "pred_csv", glue("{oc}_GAMM_age_predictions.csv")))

      # Plot
      g2 <- pred %>%
        mutate(
          # make sure it's a factor and then rename the levels
          cluster = forcats::fct_recode(
            factor(cluster, levels = c("C2","C1")),
            "Risk cluster C2" = "C2",
            "Risk cluster C1" = "C1")) %>%
        ggplot(aes(age_wave, p, ymin = lo, ymax = hi, color = cluster, fill = cluster)) +
        geom_ribbon(alpha = 0.18, color = NA) +
        geom_line(size = 0.9) +
        labs(title = glue("{oc}: Predicted prevalence over age (GAMM)"),
          x = "Age (years)", y = "Predicted prevalence") +
        theme(legend.position = "top")

      ggsave(file.path(OUT_DIR, "figures", glue("{oc}_GAMM_age_curves.png")),
           g2, width = 7.2, height = 4.6, dpi = 300)
    } else {
      readr::write_csv(
        tibble(
          note         = "GAMM prediction failed",
          engine       = attr(gam_fit, "._engine", "bam"),
          error        = as.character(pr),
          present_cols = paste(intersect(c("age_wave","age_wave_gmc","cluster","wave","sex","participant_id"),
                                       names(newdat)), collapse = ",")),
        file.path(OUT_DIR, "pred_csv", glue("{oc}_GAMM_prediction_note.csv")))
    }
  }
  
  # QC and summary bits
  glmm_ok <- !inherits(glmm_fit, "try-error") && isTRUE(is.finite(try(as.numeric(logLik(glmm_fit)), silent=TRUE)))
  glmm_sing <- if (glmm_ok) isSingular(glmm_fit, tol = 1e-4) else NA
  glmm_phi  <- if (glmm_ok) dispersion_check(glmm_fit) else NA_real_
  glmm_auc  <- if (glmm_ok) auc_qc(glmm_fit, df_o) else NA_real_
  tmb_auc   <- if (!inherits(tmb_fit,"try-error")) auc_qc(tmb_fit, df_o) else NA_real_
  gee_auc   <- if (!inherits(gee_exc,"try-error")) auc_qc(gee_exc, df_o) else NA_real_
  ar1_auc   <- if (!inherits(gee_ar1,"try-error")) auc_qc(gee_ar1, df_o) else NA_real_

  summary_rows[[oc]] <- tibble::tibble(
    outcome = oc,
    n_rows = nrow(df_o), n_ids = dplyr::n_distinct(df_o$participant_id),
    GLMM_singular = glmm_sing, GLMM_phi = round(glmm_phi,3),
    GLMM_AUC = round(glmm_auc,3), glmmTMB_AUC = round(tmb_auc,3),
    GEE_EXC_AUC = round(gee_auc,3), GEE_AR1_AUC = round(ar1_auc,3),
    GLMM_cluster   = list(extract_cluster(glmm_fit)),
    glmmTMB_cluster= list(extract_cluster(tmb_fit)),
    GEE_EXC_cluster= list(extract_cluster(gee_exc)),
    GEE_AR1_cluster= list(extract_cluster(gee_ar1))
  )
}
summary_tbl <- bind_rows(summary_rows)
write_csv(summary_tbl, file.path(OUT_DIR, "csv", "summary_table.csv"))
```

# Embedded plots & summary
```{r report, results='asis'}
for (oc in params$outcomes) {
  cat(glue("## {oc}\n\n"))
  # forest
  f_png <- file.path(OUT_DIR, "figures", glue("{oc}_GEE_EXC_cluster_OR_by_wave.png"))
  if (file.exists(f_png)) {
    cat("**Forest (OR by wave)**\n\n")
    knitr::include_graphics(f_png); cat("\n\n")
  } else {
    cat(glue("_Forest figure not found:_ `{basename(f_png)}`\n\n"))
  }
  # age curve
  a_png <- file.path(OUT_DIR, "figures", glue("{oc}_GAMM_age_curves.png"))
  if (isTRUE(params$do_gamm)) {
    if (file.exists(a_png)) {
      cat("**GAMM age curve**\n\n")
      knitr::include_graphics(a_png); cat("\n\n")
    } else {
      note_path <- file.path(OUT_DIR, "pred_csv", glue("{oc}_GAMM_prediction_note.csv"))
      if (file.exists(note_path)) {
        cat(glue("Figure not found: {basename(a_png)} details below:\n\n"))
        note <- try(readr::read_csv(note_path, show_col_types = FALSE), silent = TRUE)
        if (!inherits(note, "try-error")) print(knitr::kable(note))
        cat("\n\n")
      } else {
        cat(glue("_GAMM figure not found:_ `{basename(a_png)}`\n\n"))
      }
    }
  }
}
cat("### Summary table (QC AUCs; cluster C1 main effects as OR with 95% CI and p)\n\n")
sum_disp <- summary_tbl %>%
  mutate(
    GLMM_cluster   = purrr::map(GLMM_cluster, ensure_cluster_row),
    glmmTMB_cluster= purrr::map(glmmTMB_cluster, ensure_cluster_row),
    GEE_EXC_cluster= purrr::map(GEE_EXC_cluster, ensure_cluster_row),
    GEE_AR1_cluster= purrr::map(GEE_AR1_cluster, ensure_cluster_row)
  ) %>%
  tidyr::unnest_wider(GLMM_cluster, names_sep = "_GLMM_") %>%
  tidyr::unnest_wider(glmmTMB_cluster, names_sep = "_glmmTMB_") %>%
  tidyr::unnest_wider(GEE_EXC_cluster, names_sep = "_GEE_EXC_") %>%
  tidyr::unnest_wider(GEE_AR1_cluster, names_sep = "_GEE_AR1_") %>%
  select(outcome, n_rows, n_ids, GLMM_singular, GLMM_phi, GLMM_AUC, glmmTMB_AUC, GEE_EXC_AUC, GEE_AR1_AUC,
         starts_with("term_"), starts_with("OR_"), starts_with("CI_low_"), starts_with("CI_high_"), starts_with("p_"))
print(knitr::kable(sum_disp))
```

# Notes
- Age term used in **all** models: `age_wave_gmc`. GAMM curves are drawn over raw age (`age_wave`) but use the centered smooth internally.
- Primary inference = **GEE (EXC)** ORs by wave; GLMM/glmmTMB corroborate; GAMM visualizes age trends.
- Random effects: `(1|participant_id)` for GLMM/glmmTMB; `s(participant_id, bs="re")` for GAMM.
- Diagnostics: convergence/singularity/dispersion; ROC AUCs reported for QC only.
