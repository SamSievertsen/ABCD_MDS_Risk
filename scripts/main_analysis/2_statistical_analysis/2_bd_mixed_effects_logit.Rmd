---
title: "2. BD Mixed-Effects Logit (Repeated Status)"
output:
  html_document:
    toc: true
    toc_depth: 3
    number_sections: true
params:
  repo: !r Sys.getenv("REPO", unset = here::here())
  data_dir: "data/data_processed/analysis_datasets/"
  out_dir: "results/main_analysis/2_bd_mixed_logit"
  bd_panel_rds: "bd_panel_k2_robust.rds"
  bd_panel_csv: "bd_panel_k2_robust.csv"
  outcomes: !r c("bipolar_I","bipolar_II","bd_nos","any_bsd")
  response_var: "status"
  link_primary: "logit"
  seed: 123
  wave_ref: "ses-04A"
  ages_pred: !r c()
  include_lag_status: false
---

```{r global, include = FALSE}
# Set global env variables
knitr::opts_chunk$set(echo = TRUE, cache = FALSE, message = TRUE, warning = TRUE, results = "markup", verbose = TRUE, comment = "")

```

## Data Wrangling

Here we load data, filter to analysis outcomes, enforce references (C2, Female, site01), ensure a clean 0/1 response, compute empirical wave-median ages, and add QC tables (post-filter status counts, covariate missingness, baseline QC)

```{r environment, echo = FALSE, include = FALSE, warning = FALSE}

## Load packages, data, & set env ##
suppressPackageStartupMessages({
  library(dplyr); 
  library(tidyr); 
  library(lubridate); 
  library(glue); 
  library(forcats)
  library(broom); 
  library(broom.mixed); 
  library(lme4); 
  library(performance)
  library(emmeans); 
  library(pROC); 
  library(patchwork); 
  library(here)
  library(stringr); 
  library(ggplot2); 
  library(kableExtra); 
  library(readr)
  library(see); 
  library(DHARMa); 
  library(yardstick)
})

set.seed(params$seed)
options(scipen = 999, digits = 8)

REPO <- params$repo
DATA_DIR <- file.path(REPO, params$data_dir)
OUT_DIR  <- file.path(REPO, params$out_dir)
dir.create(OUT_DIR, recursive = TRUE, showWarnings = FALSE)

# Prefer RDS; fallback to CSV
read_panel <- function(rds_path, csv_path) {
  if (file.exists(rds_path)) readRDS(rds_path) else readr::read_csv(csv_path, show_col_types = FALSE)
}

bd_panel <- read_panel(file.path(DATA_DIR, params$bd_panel_rds),
                       file.path(DATA_DIR, params$bd_panel_csv)) %>%
  mutate(
    participant_id = as.character(participant_id),
    family_id      = factor(as.character(family_id)),
    site_factor    = factor(site_factor),
    cluster        = factor(cluster),
    wave           = factor(wave),
    outcome        = factor(outcome),
    sex            = factor(sex)
  ) %>%
  filter(outcome %in% params$outcomes)

# Require response to exist and be 0/1
stopifnot(params$response_var %in% names(bd_panel))
bd_panel <- bd_panel %>% mutate(!!params$response_var := as.integer(.data[[params$response_var]]))

# Model-ready filter (post-QC)
bd_panel_model <- bd_panel %>%
  filter(.data[[params$response_var]] %in% c(0L,1L)) %>%
  filter(!is.na(cluster),
         !is.na(sex),
         !is.na(site_factor),
         !is.na(family_id),
         !is.na(wave)) %>%
  # Require age fields present for prediction/interpretation
  filter(!is.na(age_wave), !is.na(age_wave_cwc), !is.na(age_wave_between))

# Reference levels (consistent display)
bd_panel_model <- bd_panel_model %>%
  mutate(
    cluster     = forcats::fct_relevel(cluster, "C2"),
    wave        = forcats::fct_relevel(wave, "ses-02A", "ses-04A", "ses-06A"),
    sex         = forcats::fct_relevel(sex, "Female"),
    site_factor = forcats::fct_relevel(site_factor, "site01")
  )

# Empirical wave medians for age (used when ages_pred not provided)
wave_age_medians <- bd_panel_model %>%
  group_by(wave) %>%
  summarise(age_med = median(age_wave, na.rm = TRUE), .groups = "drop") %>%
  arrange(match(wave, levels(bd_panel_model$wave)))
readr::write_csv(wave_age_medians, file.path(OUT_DIR, "wave_age_medians.csv"))
ages_empirical <- wave_age_medians$age_med %>% as.numeric() %>% round(1)

ages_pred_vec <- if (!is.null(params$ages_pred) && length(params$ages_pred) > 0) params$ages_pred else ages_empirical

# Dataset size sanity check
sizes_tbl <- tibble(
  Dataset   = "BD panel (model-ready, repeated-status)",
  Rows      = nrow(bd_panel_model),
  Unique_IDs = dplyr::n_distinct(bd_panel_model$participant_id)
)
knitr::kable(sizes_tbl, caption = "Dataset size check") %>%
  kableExtra::kable_styling(bootstrap_options = c("striped","hover","condensed","responsive"))

# Post-filter status counts (by outcome x wave x cluster)
status_counts <- bd_panel_model %>%
  group_by(outcome, wave, cluster) %>%
  summarise(
    n_intervals = dplyr::n(),
    n_status1   = sum(.data[[params$response_var]] == 1L, na.rm = TRUE),
    prev        = n_status1 / n_intervals,
    .groups = "drop"
  ) %>%
  arrange(outcome, wave, cluster)
readr::write_csv(status_counts, file.path(OUT_DIR, "bd_mixed_status_counts.csv"))
knitr::kable(status_counts, digits = 3, caption = "Status prevalence by outcome x wave x cluster") %>%
  kableExtra::kable_styling(bootstrap_options = c("striped","hover","condensed","responsive"))

# Post-filter missingness (core covariates used in models)
covars <- c("cluster","age_wave_between","age_wave_cwc","sex","wave","participant_id","family_id","site_factor")
miss_tbl <- bd_panel_model %>%
  mutate(across(all_of(covars), ~ as.numeric(is.na(.)))) %>%
  group_by(outcome) %>%
  summarise(
    n = n(),
    across(all_of(covars), ~ sum(.), .names = "n_miss_{col}"),
    across(starts_with("n_miss_"), ~ round(.x / n, 4), .names = "p_{.col}"),
    .groups = "drop"
  )
knitr::kable(miss_tbl, caption = "Missingness (post-filter) by outcome") %>%
  kableExtra::kable_styling(bootstrap_options = c("striped","hover","condensed","responsive"))

```

## Analysis Overview

**Goal.** 

Estimate repeated BD status (point prevalence at each wave) with mixed-effects logistic regression. This addresses our question of “how much BD at each time, by risk cluster,” adjusting for age and period

**Time & age handling.** 

* We use wave fixed effects (period) and the within/between age decomposition (`age_wave_cwc`, `age_wave_between`) to separate aging within youth from older vs. younger youths on average (Mundlak/hybrid approach)

**Fixed effects.** 

* `cluster` + age_wave_between + age_wave_cwc + baseline_status + sex + wave`

  * `baseline_status` is outcome-specific when available, otherwise falls back to a common `baseline_status_bd`/`baseline_status`

**Random effects.** 

* `(1 | participant_id) + (1 | family_id) + (1 | site_factor)` to capture within-person, familial, and site dependence

**Inference.** 

* Wald (model-based) SEs as primary (since family is in the RE) + CR2 (clustered by family) as robustness

**Sensitivity Analyses (optional).** 

* Complementary log-log link (rare status scenario) and optional `lag_status` for state persistence (disabled by default to avoid conditioning away cross-sectional cluster effects)

## 1. Helper Functions

```{r helpers, warning = FALSE}

# 1.1 Outcome-specific baseline status, with safe fallbacks
# For each outcome, try baseline_status_<out>, baseline_status<no_underscores>, then baseline_status_bd, then baseline_status.
derive_baseline_status <- function(df, out) {
  cands <- c(
    paste0("baseline_status_", out),
    paste0("baseline_status_", gsub("_", "", out)),
    "baseline_status_bd",
    "baseline_status"
  )
  col <- cands[cands %in% names(df)][1]
  if (is.na(col)) {
    warning("No baseline status column found for outcome = ", out, "; setting baseline_status = 0.")
    return(rep.int(0L, nrow(df)))
  }
  as.integer(df[[col]])
}

# 1.2 Optional: within-person lag of status (by participant x outcome), NA at first observed wave
add_lag_status <- function(df, resp = params$response_var) {
  df %>%
    arrange(participant_id, wave) %>%
    group_by(participant_id, outcome) %>%
    mutate(lag_status = dplyr::lag(.data[[resp]], order_by = wave)) %>%
    ungroup() %>%
    mutate(lag_status = ifelse(is.na(lag_status), 0L, as.integer(lag_status)))
}

# 1.3 Build formula (wave FE captures period; age decomposition separates within vs between)
build_formula <- function(include_lag = FALSE, link = c("logit","cloglog")) {
  link <- match.arg(link)
  rhs <- paste(
    "cluster * age_wave_between",
    "age_wave_cwc",
    "baseline_status",
    "sex",
    "wave",
    if (include_lag) "lag_status" else NULL,
    "(1 | site_factor)",
    "(1 | participant_id)",
    "(1 | family_id)",
    sep = " + "
  )
  stats::as.formula(paste(params$response_var, "~", rhs))
}

# 1.4 Safe glmer with optimizer fallback
fit_glmer_safe <- function(formula, data, link = c("logit","cloglog")) {
  link <- match.arg(link)
  fam <- if (link == "logit") binomial("logit") else binomial("cloglog")
  ctrl1 <- glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 2e5))
  fit <- try(lme4::glmer(formula, data = data, family = fam, control = ctrl1), silent = TRUE)
  if (inherits(fit, "try-error")) {
    message("Retrying with nAGQ=0 + Nelder_Mead (fallback).")
    ctrl2 <- glmerControl(optimizer = "Nelder_Mead", optCtrl = list(maxfun = 2e5))
    fit <- lme4::glmer(formula, data = data, family = fam, control = ctrl2, nAGQ = 0)
  }
  fit
}

# 1.5 Tidy tables (Wald & CR2)
tidy_wald <- function(fit) {
  broom.mixed::tidy(fit, effects = "fixed", conf.int = TRUE, conf.method = "Wald") %>%
    mutate(term = as.character(term),
           OR   = exp(estimate),
           CI_lo= exp(conf.low),
           CI_hi= exp(conf.high),
           SE   = std.error) %>%
    select(term, estimate, SE, OR, CI_lo, CI_hi, p.value)
}

tidy_cr2 <- function(fit, cluster_var = NULL) {
  test_method <- if (inherits(fit, "glmerMod")) "z" else "Satterthwaite"
  if (is.null(cluster_var)) {
    mf <- try(model.frame(fit), silent = TRUE)
    if (!inherits(mf, "try-error") && "family_id" %in% names(mf)) cluster_var <- mf$family_id
  }
  ct <- try(clubSandwich::coef_test(fit, vcov = "CR2", cluster = cluster_var, test = test_method), silent = TRUE)
  if (inherits(ct, "try-error")) {
    return(
      broom.mixed::tidy(fit, effects = "fixed", conf.int = TRUE, conf.method = "Wald") %>%
        mutate(term = as.character(term),
               estimate = estimate, SE = std.error, df = NA_real_,
               OR = exp(estimate), CI_lo = exp(conf.low), CI_hi = exp(conf.high),
               p.value = NA_real_, note = "CR2_failed") %>%
        select(term, estimate, SE, df, OR, CI_lo, CI_hi, p.value, note)
    )
  }
  as_tibble(ct) %>%
    mutate(term = as.character(term), OR = exp(beta), CI_lo = exp(CI_L), CI_hi = exp(CI_U)) %>%
    select(term, estimate = beta, SE = SE, df, OR, CI_lo, CI_hi, p.value = p_Satt)
}

# 1.6 Predictions across ages at a fixed wave (within-age = 0 for interpretability)
pred_grid_by_age <- function(fit, data, ages = ages_pred_vec, wave_ref = params$wave_ref) {
  grand_mean <- mean(data$age_wave, na.rm = TRUE)
  age_between_vals <- ages - grand_mean
  nd <- expand.grid(
    cluster          = levels(data$cluster),
    age_wave_between = age_between_vals,
    age_wave_cwc     = 0,
    baseline_status  = 0,
    sex              = levels(data$sex)[1],
    site_factor      = levels(data$site_factor)[1],
    wave             = factor(wave_ref, levels = levels(data$wave))
  )
  nd$age_years <- rep(ages, each = length(levels(data$cluster)))
  nd$pred <- predict(fit, newdata = nd, type = "response", re.form = NA)
  nd
}

# 1.7 Calibration & AUC
calibration_df <- function(fit, data) {
  pr <- predict(fit, type = "response", re.form = NA)
  df <- data %>% mutate(pred = pr, dec = dplyr::ntile(pred, 10))
  df %>%
    group_by(dec) %>%
    summarise(pred_mean = mean(pred, na.rm = TRUE),
              obs_mean  = mean(.data[[params$response_var]] == 1L, na.rm = TRUE),
              n = n(), .groups = "drop")
}

auc_interval <- function(fit, data) {
  pr <- predict(fit, type = "response", re.form = NA)
  pROC::roc(response = data[[params$response_var]], predictor = pr, quiet = TRUE)$auc %>% as.numeric()
}

# 1.8 Diagnostics
diag_report <- function(fit) {
  is_sing <- tryCatch(lme4::isSingular(fit, tol = 1e-4), error = function(e) NA)
  overK   <- tryCatch(performance::check_overdispersion(fit)$dispersion_ratio, error = function(e) NA_real_)
  conv    <- tryCatch(performance::check_convergence(fit)$converged, error = function(e) NA)
  vif_max <- tryCatch(max(performance::check_collinearity(fit)$VIF, na.rm = TRUE), error = function(e) NA_real_)
  tibble(is_singular = is_sing, converged = conv, overdispersion_K = overK, max_VIF = vif_max)
}

# 1.9 EMMs: cluster contrasts at representative ages (OR scale)
cluster_contrasts_by_age <- function(fit, data, ages = ages_pred_vec, wave_ref = params$wave_ref) {
  grand_mean <- mean(data$age_wave, na.rm = TRUE)
  age_between_vals <- ages - grand_mean
  ref_list <- list(
    age_wave_between = age_between_vals,
    age_wave_cwc     = 0,
    baseline_status  = 0,
    wave             = factor(wave_ref, levels = levels(data$wave)),
    sex              = levels(data$sex)[1],
    site_factor      = levels(data$site_factor)[1]
  )
  em <- emmeans::emmeans(fit, ~ cluster | age_wave_between, at = ref_list, type = "response", regrid = "response")
  contrast(em, method = "revpairwise") %>% broom::tidy() %>%
    mutate(age_years = round(age_wave_between + grand_mean, 2)) %>%
    select(age_years, contrast, estimate, conf.low, conf.high, p.value)
}

# 1.10 Performance metrics (Nakagawa R2, Brier, LogLoss)
brier_score <- function(obs, pr) mean((as.numeric(obs) - pr)^2, na.rm = TRUE)
log_loss    <- function(obs, pr, eps = 1e-12) {
  prc <- pmin(pmax(pr, eps), 1 - eps); -mean(as.numeric(obs) * log(prc) + (1 - as.numeric(obs)) * log(1 - prc), na.rm = TRUE)
}
perf_metrics <- function(fit, data) {
  pr <- try(predict(fit, type = "response", re.form = NA), silent = TRUE)
  R2m <- R2c <- NA_real_
  r2  <- try(performance::r2_nakagawa(fit), silent = TRUE)
  if (!inherits(r2, "try-error")) { R2m <- as.numeric(r2$R2_marginal); R2c <- as.numeric(r2$R2_conditional) }
  bs <- if (!inherits(pr, "try-error")) brier_score(data[[params$response_var]], pr) else NA_real_
  ll <- if (!inherits(pr, "try-error")) log_loss(data[[params$response_var]], pr) else NA_real_
  tibble(R2_marginal = R2m, R2_conditional = R2c, Brier = bs, LogLoss = ll)
}

# 1.11 Plot helpers, filters, and saving diagnostics
safe_or_null <- function(expr) { out <- try(expr, silent = TRUE); if (inherits(out, "try-error")) NULL else out }
wrap_title   <- function(x, width = 70) { stringr::str_wrap(x, width = width) }

keep_terms <- function(df) {
  if (!"term" %in% names(df)) return(df)
  df %>%
    filter(
      !grepl("^(Intercept)$", term),
      grepl("^cluster", term) |
        grepl("^age_wave_between$", term) |
        grepl("^age_wave_cwc$", term) |
        grepl("^baseline_status$", term) |
        grepl("^sex", term) |
        grepl("^cluster.*:age_wave_between$", term)
    )
}

save_check_model_plots <- function(fit, tag, width = 9, height = 6, dpi = 220) {
  cm <- try(performance::check_model(fit), silent = TRUE); if (inherits(cm, "try-error")) return(NULL)
  p  <- try(if (requireNamespace("see", quietly = TRUE)) see::plot(cm) else cm, silent = TRUE); if (inherits(p, "try-error")) return(NULL)
  fn <- file.path(OUT_DIR, glue::glue("check_model_{tag}.png"))
  if (requireNamespace("ragg", quietly = TRUE)) ggplot2::ggsave(fn, p, device = ragg::agg_png, width = width, height = height, units = "in", dpi = dpi) else ggplot2::ggsave(fn, p, width = width, height = height, units = "in", dpi = dpi)
  tibble(file = fn)
}

save_dharma_plots_and_tests <- function(fit, tag) {
  if (!requireNamespace("DHARMa", quietly = TRUE)) return(NULL)
  set.seed(params$seed)
  sr <- try(DHARMa::simulateResiduals(fit, n = 1000, refit = FALSE), silent = TRUE)
  if (inherits(sr, "try-error")) return(NULL)
  fn <- file.path(OUT_DIR, glue::glue("dharma_{tag}.png"))
  try({
    if (requireNamespace("ragg", quietly = TRUE)) ragg::agg_png(filename = fn, width = 1800, height = 1200, units = "px", res = 144) else png(filename = fn, width = 1800, height = 1200, res = 144)
    plot(sr); dev.off()
  }, silent = TRUE)
  td <- try(DHARMa::testDispersion(sr), silent = TRUE)
  tz <- try(DHARMa::testZeroInflation(sr), silent = TRUE)
  tibble(file = fn,
         p_dispersion = if (!inherits(td, "try-error")) td$p.value else NA_real_,
         p_zeroinfl   = if (!inherits(tz, "try-error")) tz$p.value else NA_real_)
}

```

## 2. Fit Mixed-Effects Logit Models

We fit per outcome, inject an outcome-specific `baseline_status`, optionally add `lag_status`, and export OR tables, predictions, calibration, AUC, diagnostics, and DHARMa panels. We retain a cloglog sensitivity

```{r fit, warning = FALSE}

## 2. Fit models (primary link + sensitivity), summarize, and save ##

OUTCOMES <- params$outcomes

fits_primary <- list(); wald_primary <- list(); cr2_primary <- list()
preds_primary <- list(); cal_primary <- list(); auc_primary <- list(); diag_primary <- list(); emm_primary <- list()
perf_primary <- list(); dharma_tests_primary <- list()

fits_sens <- list(); wald_sens <- list(); cr2_sens <- list()

for (out in OUTCOMES) {
  
  message("Fitting primary (", params$link_primary, "): ", out)
  dat_o <- bd_panel_model %>% filter(outcome == out) %>% droplevels()
  
  # Outcome-specific baseline status with fallback
  dat_o <- dat_o %>% mutate(baseline_status = derive_baseline_status(dat_o, out))
  
  # Optional state-persistence control (disabled by default)
  if (isTRUE(params$include_lag_status)) {
    dat_o <- add_lag_status(dat_o, resp = params$response_var)
  }
  
  # Build formula for this outcome (respect include_lag_status)
  form_o <- build_formula(include_lag = isTRUE(params$include_lag_status), link = params$link_primary)
  
  # Fit primary
  fit_o <- fit_glmer_safe(form_o, dat_o, link = params$link_primary)
  fits_primary[[out]] <- fit_o
  
  # Summaries, predictions, metrics
  wald_primary[[out]] <- safe_or_null(tidy_wald(fit_o) %>% mutate(outcome = out, model = params$link_primary, .before = 1))
  cr2_primary[[out]]  <- safe_or_null(tidy_cr2(fit_o) %>%  mutate(outcome = out, model = params$link_primary, .before = 1))
  preds_primary[[out]]<- safe_or_null(pred_grid_by_age(fit_o, dat_o) %>% mutate(outcome = out, model = params$link_primary, .before = 1))
  cal_primary[[out]]  <- safe_or_null(calibration_df(fit_o, dat_o) %>%    mutate(outcome = out, model = params$link_primary, .before = 1))
  auc_primary[[out]]  <- safe_or_null(tibble(outcome = out, model = params$link_primary, AUC = auc_interval(fit_o, dat_o)))
  diag_primary[[out]] <- safe_or_null(diag_report(fit_o) %>%             mutate(outcome = out, model = params$link_primary, .before = 1))
  perf_primary[[out]] <- safe_or_null(perf_metrics(fit_o, dat_o) %>%     mutate(outcome = out, model = params$link_primary, .before = 1))
  emm_primary[[out]]  <- safe_or_null(cluster_contrasts_by_age(fit_o, dat_o) %>% mutate(outcome = out, model = params$link_primary, .before = 1))
  
  # Diagnostics panels
  cm_info <- safe_or_null(save_check_model_plots(fit_o, glue::glue("primary_{out}")))
  dh_info <- safe_or_null(save_dharma_plots_and_tests(fit_o, glue::glue("primary_{out}")))
  if (!is.null(dh_info)) dharma_tests_primary[[out]] <- dh_info
  
  # Sensitivity: complementary log-log
  message("Fitting sensitivity (cloglog): ", out)
  form_sens <- build_formula(include_lag = isTRUE(params$include_lag_status), link = "cloglog")
  fit_s <- fit_glmer_safe(form_sens, dat_o, link = "cloglog")
  fits_sens[[out]] <- fit_s
  wald_sens[[out]] <- safe_or_null(tidy_wald(fit_s) %>% mutate(outcome = out, model = "cloglog", .before = 1))
  cr2_sens[[out]]  <- safe_or_null(tidy_cr2(fit_s) %>%  mutate(outcome = out, model = "cloglog", .before = 1))
}

# Bind and filter
wald_all_raw <- dplyr::bind_rows(purrr::compact(c(wald_primary, wald_sens)))
cr2_all_raw  <- dplyr::bind_rows(purrr::compact(c(cr2_primary, cr2_sens)))
pred_all     <- dplyr::bind_rows(purrr::compact(preds_primary))
cal_all      <- dplyr::bind_rows(purrr::compact(cal_primary))
auc_all      <- dplyr::bind_rows(purrr::compact(auc_primary))
diag_all     <- dplyr::bind_rows(purrr::compact(diag_primary))
emm_all      <- dplyr::bind_rows(purrr::compact(emm_primary))
perf_all     <- dplyr::bind_rows(purrr::compact(perf_primary))
dharma_tests_all <- dplyr::bind_rows(purrr::compact(dharma_tests_primary))

wald_all <- keep_terms(wald_all_raw)
cr2_all  <- keep_terms(cr2_all_raw)

# Save outputs
readr::write_csv(wald_all,        file.path(OUT_DIR, "bd_mixed_wald.csv"))
readr::write_csv(cr2_all,         file.path(OUT_DIR, "bd_mixed_cr2.csv"))
readr::write_csv(wald_all_raw,    file.path(OUT_DIR, "bd_mixed_wald_full.csv"))
readr::write_csv(cr2_all_raw,     file.path(OUT_DIR, "bd_mixed_cr2_full.csv"))
readr::write_csv(pred_all,        file.path(OUT_DIR, "bd_mixed_preds_by_age.csv"))
readr::write_csv(cal_all,         file.path(OUT_DIR, "bd_mixed_calibration.csv"))
readr::write_csv(auc_all,         file.path(OUT_DIR, "bd_mixed_auc.csv"))
readr::write_csv(diag_all,        file.path(OUT_DIR, "bd_mixed_diagnostics.csv"))
readr::write_csv(emm_all,         file.path(OUT_DIR, "bd_mixed_cluster_contrasts_by_age.csv"))
readr::write_csv(perf_all,        file.path(OUT_DIR, "bd_mixed_performance.csv"))
readr::write_csv(dharma_tests_all,file.path(OUT_DIR, "bd_mixed_dharma_tests.csv"))

```

## 3. Predicted Status by Cluster Across Age

Hazard-style display but for *status* (probability of being BD-positive at the wave), holding `wave = {params$wave_ref}` and within-age deviation at 0

```{r marginal effects, warning = FALSE, fig.height=11, fig.width=8.5}

plot_pred <- function(df, title) {
  ggplot(df, aes(x = age_years, y = pred, color = cluster, group = cluster)) +
    geom_line(size = 1.0) + geom_point(size = 1.8) +
    scale_y_continuous(labels = scales::percent_format(accuracy = 0.001)) +
    labs(title = wrap_title(title, 70),
         x = "Age (years)",
         y = "Predicted status probability",
         color = "Cluster") +
    theme_minimal(base_size = 8) +
    theme(legend.position = "bottom",
          legend.box = "horizontal",
          plot.title = element_text(lineheight = 0.95)) +
    guides(color = guide_legend(nrow = 1))
}

plots <- lapply(OUTCOMES, function(out) {
  df <- pred_all %>% filter(outcome == out, model == params$link_primary)
  ttl <- glue("Predicted status by cluster across age (wave={params$wave_ref}; link={params$link_primary}) – {out}")
  plot_pred(df, ttl)
})
wrap_plots(plots, ncol = 2)

```


## 4. Baseline (Wave) Effects – Period Pattern QC

Wave fixed effects reflect period/cohort differences in status prevalence (holding other covariates at reference).

```{r wave effects, warning = FALSE, fig.height=11, fig.width=8.5}
plot_wave_status <- function(fit, data, title) {
  nd <- expand.grid(
    wave             = levels(data$wave),
    cluster          = levels(data$cluster)[1],
    age_wave_between = 0,
    age_wave_cwc     = 0,
    baseline_status  = 0,
    sex              = levels(data$sex)[1],
    site_factor      = levels(data$site_factor)[1]
  )
  nd$pred <- predict(fit, newdata = nd, type = "response", re.form = NA)
  ggplot(nd, aes(x = wave, y = pred)) +
    geom_col() +
    scale_y_continuous(labels = scales::percent_format(accuracy = 0.001)) +
    labs(title = wrap_title(title, 70), x = "Wave", y = "Marginal status probability") +
    theme_minimal(base_size = 9) +
    theme(plot.title = element_text(lineheight = 0.95))
}

wave_plots <- lapply(OUTCOMES, function(out) {
  fit <- fits_primary[[out]]
  dat <- bd_panel_model %>% filter(outcome == out)
  plot_wave_status(fit, dat, glue("Wave effects – {out} (link={params$link_primary})"))
})
wrap_plots(wave_plots, ncol = 2)
```

## 5. Calibration (Deciles)

```{r calibration, warning = FALSE, fig.height=11, fig.width=8.5}
plot_cal <- function(df, title) {
  df <- dplyr::arrange(df, pred_mean)
  ggplot(df, aes(x = pred_mean, y = obs_mean)) +
    geom_point(size = 2) + geom_line() +
    geom_abline(slope = 1, intercept = 0, linetype = 2) +
    scale_x_continuous(limits = c(0,1), labels = scales::percent_format(accuracy = 0.001)) +
    scale_y_continuous(limits = c(0,1), labels = scales::percent_format(accuracy = 0.001)) +
    coord_equal() +
    labs(title = wrap_title(title, 70),
         x = "Mean predicted probability",
         y = "Observed prevalence") +
    theme_minimal(base_size = 11) +
    theme(plot.title = element_text(lineheight = 0.95))
}

plots_cal <- lapply(OUTCOMES, function(out) {
  df  <- cal_all %>% filter(outcome == out, model == params$link_primary)
  ttl <- glue("Calibration by decile – {out} (link={params$link_primary})")
  plot_cal(df, ttl)
})
wrap_plots(plots_cal, ncol = 2)

```

## 6. AUC

```{r auc, warning = FALSE}

if (nrow(auc_all) > 0) {
  knitr::kable(auc_all, digits = 3, caption = "ROC/AUC (interval-level; QC only)") %>%
    kableExtra::kable_styling(bootstrap_options = c("striped","hover","condensed","responsive"))
}

```

## 7. Inference Tables (Wald primary; CR2 robustness)

```{r inference, warning = FALSE}
pretty_term <- function(x) {
  x %>%
    stringr::str_replace_all(":", " x ") %>%
    stringr::str_replace("^cluster", "Cluster: ") %>%
    stringr::str_replace("^age_wave_between$", "Age (between-person)") %>%
    stringr::str_replace("^age_wave_cwc$", "Age (within-person)") %>%
    stringr::str_replace("^baseline_status$", "Baseline positive") %>%
    stringr::str_replace("^sex", "Sex: ") %>%
    stringr::str_replace("^wave", "Wave: ") %>%
    stringr::str_replace("lag_status", "Lagged status")
}

tbl_wald <- wald_all %>%
  mutate(term = pretty_term(term)) %>%
  select(model, outcome, term, OR, CI_lo, CI_hi, p.value)

tbl_cr2 <- cr2_all %>%
  mutate(term = pretty_term(term)) %>%
  select(model, outcome, term, OR, CI_lo, CI_hi, p.value)

knitr::kable(tbl_wald %>% arrange(outcome, model), digits = 3,
             caption = "Fixed effects (Wald) – Odds ratios with 95% CI (filtered)") %>%
  kableExtra::kable_styling(full_width = FALSE,
                            bootstrap_options = c("striped","hover","condensed","responsive"))

knitr::kable(tbl_cr2 %>% arrange(outcome, model), digits = 3,
             caption = "Fixed effects (CR2 cluster-robust by family) – Odds ratios with 95% CI (filtered)") %>%
  kableExtra::kable_styling(full_width = FALSE,
                            bootstrap_options = c("striped","hover","condensed","responsive"))
```

## 8. Cluster Contrasts at Representative Ages

```{r contrasts, warning = FALSE}
used_ages <- if (!is.null(params$ages_pred) && length(params$ages_pred) > 0) params$ages_pred else ages_pred_vec

if (exists("emm_all") && is.data.frame(emm_all) && nrow(emm_all) > 0) {
  knitr::kable(
    emm_all %>% dplyr::filter(model == params$link_primary) %>% dplyr::arrange(outcome, age_years, contrast),
    digits = 3,
    caption = glue::glue("Cluster contrasts (OR) at ages {paste(used_ages, collapse=', ')} – link = {params$link_primary}")
  ) %>% kableExtra::kable_styling(bootstrap_options = c("striped","hover","condensed","responsive"))
} else {
  message("No emmeans contrasts to display (singular fits or empty).")
}
```

## 9. Diagnostics Panels

```{r diagnostic panels, echo=FALSE, fig.align='center', out.width='100%'}
for (out in OUTCOMES) {
  cm_path <- file.path(OUT_DIR, glue::glue("check_model_primary_{out}.png"))
  dh_path <- file.path(OUT_DIR, glue::glue("dharma_primary_{out}.png"))
  ttl <- wrap_title(glue::glue("Diagnostics – {out} (top: check_model, bottom: DHARMa)"), 70)
  if (file.exists(cm_path) || file.exists(dh_path)) {
    cat("\n\n### ", ttl, "\n\n")
    imgs <- c(if (file.exists(cm_path)) cm_path else NULL, if (file.exists(dh_path)) dh_path else NULL)
    knitr::include_graphics(imgs)
  }
}
```

## Session Info

```{r session, warning = FALSE}
writeLines(c(capture.output(sessionInfo()), ""), file.path(OUT_DIR, "sessionInfo.txt"))
git_hash <- try(system(glue::glue("git -C {REPO} rev-parse --short HEAD"), intern = TRUE), silent = TRUE)
if (!inherits(git_hash, "try-error")) writeLines(git_hash, file.path(OUT_DIR, "git_commit.txt"))
```



## Session Info

```{r session, warning = FALSE}
writeLines(c(capture.output(sessionInfo()), ""), file.path(OUT_DIR, "sessionInfo.txt"))
git_hash <- try(system(glue::glue("git -C {REPO} rev-parse --short HEAD"), intern = TRUE), silent = TRUE)
if (!inherits(git_hash, "try-error")) writeLines(git_hash, file.path(OUT_DIR, "git_commit.txt"))
```

