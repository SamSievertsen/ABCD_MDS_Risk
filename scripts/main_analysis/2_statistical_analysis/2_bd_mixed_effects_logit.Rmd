---
title: "2. BD Mixed-Effects Logit"
author: "Sam A. Sievertsen"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: false
    df_print: paged
params:
  repo: !r getwd()
  data_dir: "data/data_processed/analysis_datasets/"
  out_dir: "results/main_analysis/2_bd_mixed_logit"
  bd_panel_rds: "bd_panel_k2_z_score.rds"
  bd_panel_csv: "bd_panel_k2_z_score.csv"
  outcomes: !r c("bipolar_I","bipolar_II","bd_nos","any_bsd")
  response_var: "status"
  link_primary: "logit"
  wave_ref: "ses-02A"
  ages_pred: !r NULL
  show_code: !r FALSE
  gamm_basis: "tp"
  k_age: 6
  mgcv_gamma: 1.6
  bam_discrete: !r TRUE
  do_gamm: !r TRUE
  do_gee_interaction: !r TRUE
---

## Notes
- Single age term for all models: age_wave_gmc
- GAMM curves are predicted over raw age (age_wave) by back-transforming the centered grid
- Ladder: GLMM, GLMM+baseline, glmmTMB, GEE (EXC primary, AR1 sensitivity), GAMM (bam w/ s(participant_id, bs="re"))
- Outputs: CSVs, RDS fits, forest plots (GEE OR by wave), GAMM age curves; all embedded in HTML


```{r 1 setup, message = FALSE, warning = FALSE, echo = params$show_code}

## 1. Set-Up and Packages ## 

#1.1 Chunk options and threading
knitr::opts_chunk$set(echo = params$show_code, message = FALSE, warning = FALSE, fig.align="center")
Sys.setenv(MKL_NUM_THREADS = "1", OPENBLAS_NUM_THREADS = "1", BLIS_NUM_THREADS = "1")
N_CORES <- as.integer(Sys.getenv("SLURM_CPUS_PER_TASK", Sys.getenv("OMP_NUM_THREADS", "4")))
options(mc.cores = N_CORES)
message(glue::glue("Threads -> OMP:{Sys.getenv('OMP_NUM_THREADS')}  MKL:{Sys.getenv('MKL_NUM_THREADS')}  OPENBLAS:{Sys.getenv('OPENBLAS_NUM_THREADS')}  BLIS:{Sys.getenv('BLIS_NUM_THREADS')}  |  bam nthreads:{N_CORES}"))
options(width = 120, pillar.sigfig = 3, dplyr.summarise.inform = FALSE)

#1.2 Packages
suppressPackageStartupMessages({
  library(dplyr)
  library(forcats)
  library(ggplot2)
  library(tidyr)
  library(stringr)
  library(data.table)
  library(lme4)
  library(glmmTMB)
  library(geepack)
  library(mgcv)
  library(broom)
  library(broom.mixed)
  library(pROC)
  library(emmeans)
  library(janitor)
  library(glue)
  library(readr)
  library(performance)
  library(yardstick)
  library(clubSandwich)
})

#1.3 Plot theme
theme_set(theme_bw())

```

## Data

```{r data, warning = FALSE, echo = params$show_code}

#2.1 Paths and output directories
REPO <- params$repo
DATA_DIR <- file.path(REPO, params$data_dir)
OUT_DIR <- file.path(REPO, params$out_dir)
dir.create(file.path(OUT_DIR, "csv"), recursive = TRUE, showWarnings = FALSE)
dir.create(file.path(OUT_DIR, "figures"), recursive = TRUE, showWarnings = FALSE)
dir.create(file.path(OUT_DIR, "rds"), recursive = TRUE, showWarnings = FALSE)
dir.create(file.path(OUT_DIR, "pred_csv"), recursive = TRUE, showWarnings = FALSE)

#2.2 Load z-scored BD panel dataset
#2.2.1 Set paths for panel data
rds_path <- file.path(DATA_DIR, params$bd_panel_rds)
csv_path <- file.path(DATA_DIR, params$bd_panel_csv)

#2.2.2 Load in panel darta dynamically
if (file.exists(rds_path)) {
  bd <- readRDS(rds_path)
} else {
  bd <- readr::read_csv(csv_path, show_col_types = FALSE)
}

#2.3 Standardize factor levels (C1 = low-risk, C2 = high-risk)
bd <- bd %>%
  mutate(
    wave = factor(wave, levels = c("ses-02A","ses-04A","ses-06A"), ordered = TRUE),
    cluster = factor(cluster, levels = c("C1","C2")),  # C1 = low-risk, C2 = high-risk
    sex = factor(sex, levels = c("Female","Male")),
    participant_id   = as.factor(participant_id),
    site_factor = as.factor(site_factor),
    family_id = as.factor(family_id),
    baseline_status_bd = as.factor(baseline_status_bd))

#2.3.1 Stop if all necessary columns for modeling are not present
stopifnot(all(c("outcome","status","age_wave","age_wave_gmc","cluster","wave","sex","participant_id") %in% names(bd)))

#2.4 Helper to select baseline variable
pick_baseline_col <- function(df, outcome_name) {
  cand <- paste0("baseline_status_", outcome_name)
  if (cand %in% names(df)) return(cand)
  if ("baseline_status_bd" %in% names(df)) return("baseline_status_bd")
  return(NULL)
}

#2.5 Age prediction grid for GAMM on raw age
if (!is.null(params$ages_pred)) {
  age_grid_raw <- sort(unique(params$ages_pred))
} else {
  rng <- range(bd$age_wave, na.rm = TRUE)
  age_grid_raw <- seq(floor(rng[1]), ceiling(rng[2]), by = 0.1)
}

```

## Utilities

```{r utilities, warning = FALSE, echo = params$show_code}

## 3. Utility Functions to Execute Dynamically During Modelling ## 

#3.1 Robust CI column extractor for emmeans
extract_emm_ci_cols <- function(tb) {
  nm <- names(tb)
  if (all(c("lower.CL","upper.CL") %in% nm)) return(list(low = tb$lower.CL, high = tb$upper.CL))
  if (all(c("asymp.LCL","asymp.UCL") %in% nm)) return(list(low = tb$asymp.LCL, high = tb$asymp.UCL))
  if (all(c("LCL","UCL") %in% nm))           return(list(low = tb$LCL,       high = tb$UCL))
  if (all(c("lower.HPD","upper.HPD") %in% nm)) return(list(low = tb$lower.HPD, high = tb$upper.HPD))
  list(low = rep(NA_real_, nrow(tb)), high = rep(NA_real_, nrow(tb)))
}

#3.2 QC helpers
#3.2.1 Model based prediction helper
safe_predict <- function(mod, newdata = NULL, type = "response") {
  pr <- try({
    if (inherits(mod, "merMod")) predict(mod, newdata = newdata, type = type, re.form = NA) else
    if (inherits(mod, "glmmTMB")) predict(mod, newdata = newdata, type = type, re.form = NA) else
      predict(mod, newdata = newdata, type = type)
  }, silent = TRUE)
  if (inherits(pr, "try-error")) {
    if (is.null(newdata)) rep(NA_real_, length(fitted(mod))) else rep(NA_real_, nrow(newdata))
  } else {
    as.numeric(pr)
  }
}

#3.2.2 AUC helper
auc_qc <- function(fit, df) {
  p  <- safe_predict(fit, df, "response")
  ro <- try(pROC::roc(df$status, p, quiet = TRUE), silent = TRUE)
  if (inherits(ro, "try-error")) NA_real_ else as.numeric(pROC::auc(ro))
}

#3.2.3 Dispersion check helper
dispersion_check <- function(mod) {
  r  <- try(residuals(mod, type = "pearson"), silent = TRUE)
  df <- try(df.residual(mod),               silent = TRUE)
  if (inherits(r,"try-error") || inherits(df,"try-error") || is.null(df) || df <= 0) return(NA_real_)
  sum(r^2, na.rm = TRUE) / df
}

#3.3 Extract high- vs low-risk cluster effect (C2 vs C1): OR + CI + p
extract_cluster <- function(fit) {
  out <- tibble::tibble(term = "clusterC2", OR = NA_real_, CI_low = NA_real_,
                        CI_high = NA_real_, p = NA_real_)
  if (inherits(fit, "merMod")) {
    sm <- coef(summary(fit)); if (!"clusterC2" %in% rownames(sm)) return(out)
    b  <- sm["clusterC2","Estimate"]; se <- sm["clusterC2","Std. Error"]
    z  <- b / se; p <- 2 * pnorm(abs(z), lower.tail = FALSE)
    tibble::tibble(term = "clusterC2",
                   OR = exp(b),
                   CI_low = exp(b - 1.96 * se),
                   CI_high = exp(b + 1.96 * se),
                   p = p)
  } else if (inherits(fit, "glmmTMB")) {
    sm <- summary(fit)$coefficients$cond
    if (is.null(sm) || !"clusterC2" %in% rownames(sm)) return(out)
    b  <- sm["clusterC2","Estimate"]; se <- sm["clusterC2","Std. Error"]
    z  <- b / se; p <- 2 * pnorm(abs(z), lower.tail = FALSE)
    tibble::tibble(term = "clusterC2",
                   OR = exp(b),
                   CI_low = exp(b - 1.96 * se),
                   CI_high = exp(b + 1.96 * se),
                   p = p)
  } else if ("geeglm" %in% class(fit)) {
    sm <- summary(fit)$coefficients; rn <- rownames(sm)
    if (!"clusterC2" %in% rn) return(out)
    b  <- sm["clusterC2","Estimate"]; se <- sm["clusterC2","Robust S.E."]
    z  <- b / se; p <- 2 * pnorm(abs(z), lower.tail = FALSE)
    tibble::tibble(term = "clusterC2",
                   OR = exp(b),
                   CI_low = exp(b - 1.96 * se),
                   CI_high = exp(b + 1.96 * se),
                   p = p)
  } else out
}

#3.4 EMMEANS: cluster C2 vs C1 OR by wave
or_by_wave_emm <- function(fit, df, model, outcome) {
  if (inherits(fit, "try-error")) return(NULL)
  emm <- try(emmeans(fit, ~ cluster | wave, type = "link"), silent = TRUE)
  if (inherits(emm, "try-error")) return(NULL)
  # revpairwise + levels(cluster) = c("C1","C2") => C2 - C1 (high vs low)
  sm  <- try(contrast(emm, method = "revpairwise") %>% summary(infer = TRUE),
             silent = TRUE)
  if (inherits(sm, "try-error")) return(NULL)
  tb <- as_tibble(sm)
  ci <- extract_emm_ci_cols(tb)
  tibble::tibble(
    outcome = outcome,
    model = model,
    wave = as.character(tb$wave),
    OR = exp(tb$estimate),
    CI_low  = exp(ci$low),
    CI_high = exp(ci$high)
  )
}

#3.5 Wave labels with C2 (high-risk) n and median age (overall)
wave_labels_with_sample_age <- function(df) {
  labs <- df %>%
    group_by(wave) %>%
    summarize(
      n_C2 = sum(cluster == "C2", na.rm = TRUE),
      med_age_all = median(age_wave, na.rm = TRUE),
      .groups = "drop") %>%
    mutate(lab = glue("{wave}\nC2 n={n_C2}, med age(all)={round(med_age_all,1)}")) %>%
    dplyr::select(wave, lab)
  labs
}

#3.6 Fitters: GLMM, glmmTMB, GEE, GAMM
#3.6.1 Fit GLMM model
fit_glmm <- function(df, base_col) {
  rhs <- paste("cluster + wave + sex + age_wave_gmc", base_col, sep = " + ")
  fml <- as.formula(glue("status ~ {rhs} + (1|participant_id)"))
  ctrl <- glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 2e5))
  try(glmer(fml, data = df, family = binomial(link = params$link_primary),
            control = ctrl, nAGQ = 0),
      silent = TRUE)
}

#3.6.2 Fit glmmTMB
fit_glmmtmb <- function(df, base_col) {
  rhs <- paste("cluster + wave + sex + age_wave_gmc", base_col, sep = " + ")
  fml <- as.formula(glue("status ~ {rhs} + (1|participant_id)"))
  try(glmmTMB(fml, data = df, family = binomial(link = params$link_primary)),
      silent = TRUE)
}

#3.6.3 Fit GEE
fit_gee <- function(df, corstr = "exchangeable", link = "logit", interaction = FALSE) {
  fml <- if (isTRUE(interaction)) {
    as.formula(status ~ cluster * wave + sex + baseline_status_bd + age_wave_gmc)
  } else {
    as.formula(status ~ cluster + wave + sex + baseline_status_bd + age_wave_gmc)
  }
  try(
    geeglm(fml, id = participant_id, data = df,
           family = binomial(link = link),
           corstr = corstr, std.err = "san.se"),
    silent = TRUE
  )
}

#3.6.4 Fit GAMM
fit_gamm <- function(df) {
  fml <- as.formula(glue::glue(
    "status ~ cluster + wave + sex + s(age_wave_gmc, cluster, bs = 'fs', k = {params$k_age}) + s(participant_id, bs = 're')"
  ))
  try(mgcv::bam(
    fml, data = df, family = binomial(link = params$link_primary),
    discrete = isTRUE(params$bam_discrete), nthreads = N_CORES, method = "fREML",
    select = TRUE, gamma = params$mgcv_gamma
  ), silent = TRUE)
}

#3.7 Ensure list column has a 1-row tibble for high- vs low-risk cluster stats
ensure_cluster_row <- function(x) {
  if (inherits(x, "try-error") || is.null(x) || !nrow(x)) {
    return(tibble::tibble(term = "clusterC2", OR = NA_real_,
                          CI_low = NA_real_, CI_high = NA_real_, p = NA_real_))
  }
  x %>%
    dplyr::filter(term == "clusterC2") %>%
    dplyr::select(term, OR, CI_low, CI_high, p) %>%
    { if (!nrow(.)) tibble::tibble(term = "clusterC2", OR = NA_real_,
                                   CI_low = NA_real_, CI_high = NA_real_, p = NA_real_)
      else . }
}

#3.8 Tidy model coefficients and add ORs / CIs
tidy_or <- function(x, term_keep = NULL) {
  
  #3.8.1 Tidy the model safely
  tx <- tryCatch({
    if (inherits(x, "merMod")) {
      broom.mixed::tidy(x, effects = "fixed")
    } else if (inherits(x, "glmmTMB")) {
      broom.mixed::tidy(x, effects = "fixed") %>%
        dplyr::filter(.data$component %in% c("cond", NA))
    } else {
      broom::tidy(x)
    }
  }, error = function(e) tibble::tibble())

  if (!nrow(tx)) {
    return(tibble::tibble(
      term = character(), estimate = numeric(),
      OR = numeric(), CI_low = numeric(), CI_high = numeric()))
  }

  #3.8.2 Pick a standard error column robustly (no NULLs)
  se_name <- intersect(
    c("std.error", "Std. Error", "SE", "robust.se", "robust.SE", "Robust S.E.", "robust_se"),
    names(tx))
  se <- if (length(se_name)) {
    as.numeric(tx[[se_name[1]]])
  } else {
    rep(NA_real_, nrow(tx))
  }

  #3.8.3 Optional term filter
  if (!is.null(term_keep)) {
    tx <- dplyr::filter(tx, stringr::str_detect(.data$term, term_keep))
  }

  #3.8.4 Add OR + Wald CI on the logit scale
  dplyr::mutate(
    tx,
    OR = exp(.data$estimate),
    CI_low = exp(.data$estimate - 1.96 * se),
    CI_high = exp(.data$estimate + 1.96 * se))
}

```

## Per-outcome modeling

```{r modeling, message = FALSE, warning = FALSE, echo = params$show_code}

## 4. Main: Per-Outcome Modeling ##

#4.1 Configure outcomes and object to store results
OUTS <- params$outcomes
summary_rows <- list()

#4.2 Loop over BD outcomes
for (oc in OUTS) {

  #4.2.1 Outcome-specific dataset and baseline term
  df_o <- bd %>%
    filter(outcome == oc) %>%
    drop_na(status, cluster, wave, sex, participant_id, age_wave, age_wave_gmc)
  if (!nrow(df_o)) next

  base_col <- pick_baseline_col(df_o, oc)
  base_col <- ifelse(is.null(base_col), "1", base_col)

  #4.2.2 Age grid (per outcome) for smoother GAMM curves
  gm_age <- mean(df_o$age_wave, na.rm = TRUE)
  rng <- stats::quantile(df_o$age_wave, probs = c(0.05, 0.95), na.rm = TRUE)
  age_grid <- seq(floor(rng[1]), ceiling(rng[2]), by = 0.1)

  #4.2.3 Fits: GLMM, glmmTMB, GEE (EXC/AR1, with/without interaction), GAMM
  glmm_fit <- fit_glmm(df_o, base_col)
  glmmb_fit <- if (base_col != "1") fit_glmm(df_o, base_col) else glmm_fit 
  tmb_fit <- fit_glmmtmb(df_o, base_col)
  gee_exc <- fit_gee(df_o, corstr = "exchangeable", link = params$link_primary, interaction = FALSE)
  gee_ar1 <- fit_gee(df_o, corstr = "ar1", link = params$link_primary, interaction = FALSE)
  gee_ok <- !inherits(gee_exc,"try-error")
  ar1_ok <- !inherits(gee_ar1,"try-error")

  #4.2.3.1 If GEE EXC interaction model is specified in params, fit that too
  gee_exc_int <- if (isTRUE(params$do_gee_interaction))
    fit_gee(df_o, "exchangeable", params$link_primary, interaction = TRUE) else
    structure("off", class="try-error")

  #4.2.3.2 If GEE AR1 interaction model is specified in params, fit that too
  gee_ar1_int <- if (isTRUE(params$do_gee_interaction))
    fit_gee(df_o, "ar1", params$link_primary, interaction = TRUE) else
    structure("off", class="try-error")

  #4.2.3.3 Check and if present store any GEE interaction model(s)
  gee_int_ok <- !inherits(gee_exc_int,"try-error")
  ar1_int_ok <- !inherits(gee_ar1_int,"try-error")

  #4.2.3.4 If specified, fit GAMM
  gam_fit <- if (isTRUE(params$do_gamm)) fit_gamm(df_o) else structure("off", class = "try-error")

  #4.2.4 Save RDS fits
  try(saveRDS(glmm_fit, file.path(OUT_DIR, "rds", glue("{oc}_GLMM.rds")), compress =
                "xz"), silent = TRUE)
  if (base_col != "1") {
    try(saveRDS(glmmb_fit, file.path(OUT_DIR, "rds", glue("{oc}_GLMM_with_baseline.rds")), compress =
                  "xz"), silent = TRUE)
  }
  try(saveRDS(tmb_fit, file.path(OUT_DIR, "rds", glue("{oc}_glmmTMB.rds")), compress =
                "xz"), silent = TRUE)
  
  if (gee_ok) {
    try(saveRDS(gee_exc, file.path(OUT_DIR, "rds", glue("{oc}_GEE_EXC.rds")), compress =
                  "xz"), silent = TRUE)
    gee_tbl <- tidy_or(gee_exc)
    gee_ex_pair <- or_by_wave_emm(gee_exc, df_o, "GEE_EXC", oc)
    if (nrow(gee_tbl))
      write_csv(gee_tbl %>% mutate(outcome = oc),
                file.path(OUT_DIR, "csv", glue("{oc}_GEE_EXC_fixed_ORs.csv")))
    if (!is.null(gee_ex_pair))
      write_csv(gee_ex_pair, file.path(
        OUT_DIR,
        "csv",
        glue("{oc}_GEE_EXC_cluster_OR_by_wave.csv")))
  }
  if (ar1_ok) {
    try(saveRDS(gee_ar1, file.path(OUT_DIR, "rds", glue("{oc}_GEE_AR1.rds")), compress =
                  "xz"), silent = TRUE)
    ar1_tbl <- tidy_or(gee_ar1)
    gee_ar_pair <- or_by_wave_emm(gee_ar1, df_o, "GEE_AR1", oc)
    if (nrow(ar1_tbl))
      write_csv(ar1_tbl %>% mutate(outcome = oc),
                file.path(OUT_DIR, "csv", glue("{oc}_GEE_AR1_fixed_ORs.csv")))
    if (!is.null(gee_ar_pair))
      write_csv(gee_ar_pair, file.path(
        OUT_DIR,
        "csv",
        glue("{oc}_GEE_AR1_cluster_OR_by_wave.csv")))
  }
  
  if (gee_int_ok) {
    try(saveRDS(gee_exc_int, file.path(OUT_DIR, "rds", glue("{oc}_GEE_EXC_INT.rds")), compress =
                  "xz"), silent = TRUE)
    gee_tbl_int <- tidy_or(gee_exc_int)
    gee_ex_pair_int <- or_by_wave_emm(gee_exc_int, df_o, "GEE_EXC_INT", oc)
    if (nrow(gee_tbl_int))
      write_csv(gee_tbl_int %>% mutate(outcome = oc),
                file.path(OUT_DIR, "csv", glue("{oc}_GEE_EXC_INT_fixed_ORs.csv")))
    if (!is.null(gee_ex_pair_int))
      write_csv(gee_ex_pair_int, file.path(
        OUT_DIR,
        "csv",
        glue("{oc}_GEE_EXC_INT_cluster_OR_by_wave.csv")))
  }
  if (ar1_int_ok) {
    try(saveRDS(gee_ar1_int, file.path(OUT_DIR, "rds", glue("{oc}_GEE_AR1_INT.rds")), compress =
                  "xz"), silent = TRUE)
    ar1_tbl_int <- tidy_or(gee_ar1_int)
    gee_ar_pair_int <- or_by_wave_emm(gee_ar1_int, df_o, "GEE_AR1_INT", oc)
    if (nrow(ar1_tbl_int))
      write_csv(ar1_tbl_int %>% mutate(outcome = oc),
                file.path(OUT_DIR, "csv", glue("{oc}_GEE_AR1_INT_fixed_ORs.csv")))
    if (!is.null(gee_ar_pair_int))
      write_csv(gee_ar_pair_int, file.path(
        OUT_DIR,
        "csv",
        glue("{oc}_GEE_AR1_INT_cluster_OR_by_wave.csv")))
  }

  #4.2.5 Tidy OR tables
  glmm_tbl <- if (!inherits(glmm_fit, "try-error"))  tidy_or(glmm_fit)  else tibble()
  glmmb_tbl <- if (base_col != "1" && !inherits(glmmb_fit,"try-error")) tidy_or(glmmb_fit) else tibble()
  tmb_tbl <- if (!inherits(tmb_fit, "try-error")) tidy_or(tmb_fit) else tibble()
  gee_tbl <- if (!inherits(gee_exc, "try-error")) tidy_or(gee_exc) else tibble()
  ar1_tbl <- if (!inherits(gee_ar1, "try-error")) tidy_or(gee_ar1) else tibble()

  #4.2.6 Write CSVs of results
  write_csv(glmm_tbl  %>% mutate(outcome = oc), file.path(OUT_DIR, "csv", glue("{oc}_GLMM_fixed_ORs.csv")))
  if (nrow(glmmb_tbl)) write_csv(glmmb_tbl %>% mutate(outcome = oc), file.path(OUT_DIR, "csv", glue("{oc}_GLMM_with_baseline_fixed_ORs.csv")))
  write_csv(tmb_tbl   %>% mutate(outcome = oc), file.path(OUT_DIR, "csv", glue("{oc}_glmmTMB_fixed_ORs.csv")))
  if (nrow(gee_tbl))  write_csv(gee_tbl  %>% mutate(outcome = oc), file.path(OUT_DIR, "csv", glue("{oc}_GEE_EXC_fixed_ORs.csv")))
  if (nrow(ar1_tbl))  write_csv(ar1_tbl  %>% mutate(outcome = oc), file.path(OUT_DIR, "csv", glue("{oc}_GEE_AR1_fixed_ORs.csv")))

  #4.2.7 OR by wave via emmeans (C2 vs C1)
  gee_ex_pair <- or_by_wave_emm(gee_exc, df_o, "GEE_EXC", oc)
  gee_ar_pair <- or_by_wave_emm(gee_ar1, df_o, "GEE_AR1", oc)
  if (!is.null(gee_ex_pair)) write_csv(gee_ex_pair, file.path(OUT_DIR, "csv", glue("{oc}_GEE_EXC_cluster_OR_by_wave.csv")))
  if (!is.null(gee_ar_pair)) write_csv(gee_ar_pair, file.path(OUT_DIR, "csv", glue("{oc}_GEE_AR1_cluster_OR_by_wave.csv")))

  #4.2.8 Forest plot: additive (primary GEE EXC)
  if (gee_ok && !is.null(gee_ex_pair) && nrow(gee_ex_pair)) {
    labs <- wave_labels_with_sample_age(df_o)  
    g <- gee_ex_pair %>%
      mutate(wave = as.character(wave)) %>%
      left_join(labs %>% mutate(wave = as.character(wave)), by = "wave") %>%
      mutate(lab = factor(lab, levels = unique(lab))) %>%
      ggplot(aes(x = lab, y = OR, ymin = CI_low, ymax = CI_high)) +
      geom_hline(yintercept = 1, linetype = 2) +
      geom_pointrange(position = position_dodge(width = 0.2)) +
      labs(
        title = glue("{oc}: Cluster C2 vs C1 OR by wave (GEE EXC, additive)"),
        y = "Odds ratio",
        x = "Wave (n_C2; median age)") +
      theme(panel.grid.minor = element_blank())
    ggsave(file.path(OUT_DIR, "figures", glue("{oc}_GEE_EXC_cluster_OR_by_wave.png")),
           g, width = 7.2, height = 4.6, dpi = 300)
  }

  #4.2.9 Forest plot: interaction model (cluster x wave)
  if (gee_int_ok && !is.null(gee_ex_pair_int) && nrow(gee_ex_pair_int)) {
    labs <- wave_labels_with_sample_age(df_o)
    g_int <- gee_ex_pair_int %>%
      mutate(wave = as.character(wave)) %>%
      left_join(labs %>% mutate(wave = as.character(wave)), by = "wave") %>%
      mutate(lab = factor(lab, levels = unique(lab))) %>%
      ggplot(aes(x = lab, y = OR, ymin = CI_low, ymax = CI_high)) +
      geom_hline(yintercept = 1, linetype = 2) +
      geom_pointrange(position = position_dodge(width = 0.2)) +
      labs(
        title = glue("{oc}: Cluster C2 vs C1 OR by wave (GEE EXC, cluster x wave)"),
        y = "Odds ratio",
        x = "Wave (n_C2; median age)") +
      theme(panel.grid.minor = element_blank())
    ggsave(file.path(OUT_DIR, "figures", glue("{oc}_GEE_EXC_INT_cluster_OR_by_wave.png")),
           g_int, width = 7.2, height = 4.6, dpi = 300)
  }

  #4.2.10 GAMM predictions & age curves (if enabled)
  if (!inherits(gam_fit,"try-error")) {

    #4.2.10.1 Predict along the per-outcome trimmed age grid; fix wave/sex for a clean age curve
    newdat <- tidyr::crossing(
      age_wave = age_grid,
      cluster = factor(c("C1","C2"), levels = levels(df_o$cluster)),
      wave = factor(params$wave_ref,
                    levels = levels(df_o$wave),
                    ordered = is.ordered(df_o$wave)),
      sex = factor("Female", levels = levels(df_o$sex))) %>%
      mutate(
        
        #4.2.10.2 Center age using the outcome-specific grand mean from the fit
        age_wave_gmc = age_wave - gm_age,
        
        #4.2.10.3 Provide a valid subject level (we'll exclude this RE in prediction)
        participant_id = factor(levels(df_o$participant_id)[1],
                                levels = levels(df_o$participant_id)))

    #4.2.10.4 Exclude the subject random effect so curves are marginal over participants
    pr <- try(
      predict(gam_fit, newdata = newdat, type = "link", se.fit = TRUE,
              exclude = "s(participant_id)"),
      silent = TRUE)

    #4.2.10.5 Store model predictions for GAMM if specified
    if (!inherits(pr,"try-error")) {
      pred <- newdat %>%
        mutate(
          eta = as.numeric(pr$fit),
          se = as.numeric(pr$se.fit),
          p = plogis(eta),
          lo = plogis(eta - 1.96 * se),
          hi = plogis(eta + 1.96 * se),
          outcome = oc,
          age_var_used = "age_wave_gmc",
          gamm_engine = "bam")

      #4.2.10.6 Save preds
      write_csv(pred, file.path(OUT_DIR, "pred_csv", glue("{oc}_GAMM_age_predictions.csv")))

      #4.2.10.7 Plot age curves by risk cluster
      g2 <- pred %>%
        mutate(
          cluster = forcats::fct_recode(
            factor(cluster, levels = c("C1","C2")),
            "Low-risk cluster (C1)" = "C1",
            "High-risk cluster (C2)" = "C2")) %>%
        ggplot(aes(age_wave, p, ymin = lo, ymax = hi,
                   color = cluster, fill = cluster)) +
        geom_ribbon(alpha = 0.18, color = NA) +
        geom_line(size = 0.9) +
        labs(
          title = glue("{oc}: Predicted prevalence over age (GAMM)"),
          x = "Age (years)",
          y = "Predicted prevalence") +
        theme(legend.position = "top")
      ggsave(file.path(OUT_DIR, "figures", glue("{oc}_GAMM_age_curves.png")),
             g2, width = 7.2, height = 4.6, dpi = 300)
    } else {
      readr::write_csv(
        tibble(
          note = "GAMM prediction failed",
          engine = attr(gam_fit, "._engine", "bam"),
          error = as.character(pr),
          present_cols = paste(
            intersect(c("age_wave","age_wave_gmc","cluster","wave","sex","participant_id"),
                      names(newdat)),
            collapse = ",")),
        file.path(OUT_DIR, "pred_csv", glue("{oc}_GAMM_prediction_note.csv")))
    }
  }
  
  #4.2.11 QC for each model
  glmm_ok <- !inherits(glmm_fit, "try-error") &&
              isTRUE(is.finite(try(as.numeric(logLik(glmm_fit)), silent=TRUE)))
  glmm_sing <- if (glmm_ok) isSingular(glmm_fit, tol = 1e-4) else NA
  glmm_phi <- if (glmm_ok) dispersion_check(glmm_fit) else NA_real_
  glmm_auc <- if (glmm_ok) auc_qc(glmm_fit, df_o) else NA_real_
  tmb_auc <- if (!inherits(tmb_fit,"try-error")) auc_qc(tmb_fit, df_o) else NA_real_
  gee_auc <- if (!inherits(gee_exc,"try-error")) auc_qc(gee_exc, df_o) else NA_real_
  ar1_auc <- if (!inherits(gee_ar1,"try-error")) auc_qc(gee_ar1, df_o) else NA_real_

  #4.2.12 Summary of each model
  summary_rows[[oc]] <- tibble::tibble(
    outcome = oc,
    n_rows = nrow(df_o),
    n_ids = dplyr::n_distinct(df_o$participant_id),
    GLMM_singular = glmm_sing,
    GLMM_phi = round(glmm_phi, 3),
    GLMM_AUC = round(glmm_auc, 3),
    glmmTMB_AUC = round(tmb_auc, 3),
    GEE_EXC_AUC = round(gee_auc, 3),
    GEE_AR1_AUC = round(ar1_auc, 3),
    GLMM_cluster = list(extract_cluster(glmm_fit)),
    glmmTMB_cluster = list(extract_cluster(tmb_fit)),
    GEE_EXC_cluster = list(extract_cluster(gee_exc)),
    GEE_AR1_cluster = list(extract_cluster(gee_ar1)))
}

#4.3 Bind summary table across outcomes
summary_tbl <- bind_rows(summary_rows)
write_csv(summary_tbl, file.path(OUT_DIR, "csv", "summary_table.csv"))

```

## Embedded plots & summary

```{r summary report, warning = FALSE, echo = params$show_code, results='asis'}

## 5. Embedded Plots and Summary ##

#5.1 For each relevant analysis outcome/modeling approach, print and store figures
for (oc in params$outcomes) {
  cat(glue("## {oc}\n\n"))
  
  #5.1.1 Forest plot of ORs
  f_png <- file.path(OUT_DIR, "figures", glue("{oc}_GEE_EXC_cluster_OR_by_wave.png"))
  if (file.exists(f_png)) {
    cat("**Forest (OR by wave)**\n\n")
    knitr::include_graphics(f_png); cat("\n\n")
  } else {
    cat(glue("_Forest figure not found:_ `{basename(f_png)}`\n\n"))
  }
  
  #5.1.2 GAMM age curves
  a_png <- file.path(OUT_DIR, "figures", glue("{oc}_GAMM_age_curves.png"))
  if (isTRUE(params$do_gamm)) {
    if (file.exists(a_png)) {
      cat("**GAMM age curve**\n\n")
      knitr::include_graphics(a_png); cat("\n\n")
    } else {
      note_path <- file.path(OUT_DIR, "pred_csv", glue("{oc}_GAMM_prediction_note.csv"))
      if (file.exists(note_path)) {
        cat(glue("Figure not found: {basename(a_png)} details below:\n\n"))
        note <- try(readr::read_csv(note_path, show_col_types = FALSE), silent = TRUE)
        if (!inherits(note, "try-error")) print(knitr::kable(note))
        cat("\n\n")
      } else {
        cat(glue("_GAMM figure not found:_ `{basename(a_png)}`\n\n"))
      }
    }
  }
}

#5.2 Summary table for each model
#5.2.1 Print header for summary table
cat("### Summary table (QC AUCs; cluster C2 main effects as OR with 95% CI and p)\n\n")

#5.2.2 Create and clean the summary table
sum_disp <- summary_tbl %>%
  mutate(
    GLMM_cluster = purrr::map(GLMM_cluster, ensure_cluster_row),
    glmmTMB_cluster= purrr::map(glmmTMB_cluster, ensure_cluster_row),
    GEE_EXC_cluster= purrr::map(GEE_EXC_cluster, ensure_cluster_row),
    GEE_AR1_cluster= purrr::map(GEE_AR1_cluster, ensure_cluster_row)) %>%
  tidyr::unnest_wider(GLMM_cluster, names_sep = "_GLMM_") %>%
  tidyr::unnest_wider(glmmTMB_cluster, names_sep = "_glmmTMB_") %>%
  tidyr::unnest_wider(GEE_EXC_cluster, names_sep = "_GEE_EXC_") %>%
  tidyr::unnest_wider(GEE_AR1_cluster, names_sep = "_GEE_AR1_") %>%
  dplyr::select(outcome, n_rows, n_ids, GLMM_singular, GLMM_phi, GLMM_AUC, glmmTMB_AUC, GEE_EXC_AUC, GEE_AR1_AUC,
         starts_with("term_"), starts_with("OR_"), starts_with("CI_low_"), starts_with("CI_high_"), starts_with("p_"))

#5.2.3 Print the summary table
print(knitr::kable(sum_disp))

```

## Notes
- Age term used in all models: `age_wave_gmc`. GAMM curves are drawn over raw age (`age_wave`) but use the centered smooth internally
- Primary inference = GEE (EXC) ORs by wave; GLMM/glmmTMB corroborate; GAMM visualizes age trends
- Random effects: `(1|participant_id)` for GLMM/glmmTMB; `s(participant_id, bs="re")` for GAMM
- Diagnostics: convergence/singularity/dispersion; ROC AUCs reported for QC only
