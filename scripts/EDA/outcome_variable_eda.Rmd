---
title: "Mood Disorder & Suicidality Outcome Variable EDA"
author: "Sam A. Sievertsen"
date: "`r Sys.Date()`"
output:
  html_document:
    self_contained: true
---

```{r global, include = FALSE}

# Set global env variables
knitr::opts_chunk$set(warning = FALSE, message = FALSE, comment = "")

```

# Exploratory Data Analysis (EDA) of variables to be used as outcome metrics related to mood disorders and suicidality in the ABCD dataset

The most up to date list of variables to used as outcomes in the current study, including their role, domain, details of each variable as it relates to the ABCD dataset, etc., can be [found here](https://ohsuitg-my.sharepoint.com/:x:/r/personal/sievertsen_ohsu_edu/Documents/Huber_Lab/FYP/Project_Planning/ABCD_Mood_Disorder_Risk_Model_Variables_010624_SS.xlsx?d=w286583f8914b4ab5a402e36ce8c36291&csf=1&web=1&e=ieCAKt&nav=MTVfezIxMDEwOEMxLTFFMjktNERDMi1CQTE4LTM0QTE2NzA0MEQ2RX0). 

The following report contains information regarding the: 

  1. Integrity of the data
  
  2. Assessment of outliers in the data
  
  3. Skewness + appropriateness of the mean as the measure of central tendency for continuous variables
  
  4. Shape of each variables' distribution

```{r environment, echo = FALSE, include = FALSE, warning = FALSE}

# Load necessary packages + environmental variables
library(knitr)
library(kableExtra)
library(dplyr)
library(tidyr)
library(ggplot2)
library(networkD3)
library(patchwork)
library(purrr)
library(htmltools)
library(moments)
options(scipen = 999, digits = 8)

# Read in raw data generated in DEAP
raw_data <- read.csv("../../data/data_raw/dataset.csv")

```

## Data Wrangling 

This section prepares the data for EDA of outcomes via the following process:

| Step | Purpose |
|------|---------|
| **1 - Define raw KSADS™ columns** | For every outcome (passive/active suicidal ideation, suicide attempt, NSSI, Bipolar I, Bipolar II, Any-BSD) we list all relevant parent- and youth-report “current” and “past” diagnostic flags. |
| **2 - Create binary variables** | Using `dplyr::case_when()` we mark a variable as 1 if any constituent flag = 1, 0 if at least one flag = 0 but none are 1, and NA only when every constituent column is missing. guarantees NA only when true data absence, not when zeros are present |
| **3 - Define depression qualifiers** | Collect all parent + youth Major Depressive Disorder and Persistent Depressive Disorder (current, past, partial-remission) flags |
| **4 - Identify “past mania/hypomania only” flags** | `bd1_past_mania_vars` (BD-I recent past manic) and `bd2_past_mania_vars` (BD-II recent past hypomanic) |
| **5 - Rescore Bipolar I & II at baseline (ses-00A) and 2-year (ses-02A)** | If a row shows past manic/hypomanic episode and the youth has any depressive-disorder flag → keep diagnosis = 1. If past manic/hypomanic but no depression history → force diagnosis = 0. All other rows (different sessions or current episodes) keep their original value |

**Why we rescore Bipolar I/II “past episode manic/hypomanic” flags**
      
The ABCD Study’s KSADS-COMP v1.0 over-diagnoses Lifetime Bipolar-I by allowing a *single* past manic flag to qualify. [Barch et al. (2021)](https://doi.org/10.1016/j.dcn.2021.101031) note:
      
      > “The computerized KSADS 1.0 shows **higher than expected rates** of caregiver- and youth-reported *past manic episodes* (e.g., caregiver-reported prevalence of Bipolar I Disorder, most recent past episode manic is 2.6%). We recommend rescoring such cases so that the youth must also meet criteria for a current or past depressive disorder to satisfy diagnostic criteria.”
    
Following this recommendation we:
      
  - restrict rescoring to baseline and 2-year follow-up waves (those using KSADS-v1 past-episode items);

  - require any lifetime MDD/PDD flag alongside past mania/hypomania before endorsing Bipolar I or II.
    
This likely yields more realistic prevalence estimates while keeping current-episode diagnoses intact and preserving the longitudinal structure needed for survival and mixed-effects models.

```{r data wrangling, echo = FALSE, include = FALSE, warning = FALSE}

## Data Wrangling ##

#1. Clean the outcome data 
#1.1 Clean the KSADS-COMP Diagnosis Data
#1.11 Retain only columns of interest
raw_data_trimmed <- raw_data %>% 
  dplyr::select(c(participant_id, session_id, mh_p_ksads__suic__pass__past_dx, mh_p_ksads__suic__actv__past_dx, mh_p_ksads__suic__actv__mthd__past_dx, mh_p_ksads__suic__actv__int__past_dx, mh_p_ksads__suic__actv__plan__past_dx, mh_p_ksads__suic__pass__pres_dx, mh_p_ksads__suic__actv__pres_dx, mh_p_ksads__suic__actv__mthd__pres_dx, mh_p_ksads__suic__actv__int__pres_dx, mh_p_ksads__suic__actv__plan__pres_dx, mh_y_ksads__suic__pass__past_dx, mh_y_ksads__suic__actv__past_dx, mh_y_ksads__suic__actv__mthd__past_dx, mh_y_ksads__suic__actv__int__past_dx, mh_y_ksads__suic__actv__plan__past_dx, mh_y_ksads__suic__pass__pres_dx, mh_y_ksads__suic__actv__pres_dx, mh_y_ksads__suic__actv__mthd__pres_dx, mh_y_ksads__suic__actv__int__pres_dx, mh_y_ksads__suic__actv__plan__pres_dx, mh_p_ksads__suic__atmpt__intr__past_dx, mh_p_ksads__suic__atmpt__abrt__past_dx, mh_p_ksads__suic__atmpt__past_dx, mh_p_ksads__suic__atmpt__intr__pres_dx, mh_p_ksads__suic__atmpt__abrt__pres_dx, mh_p_ksads__suic__atmpt__pres_dx, mh_y_ksads__suic__atmpt__intr__past_dx, mh_y_ksads__suic__atmpt__abrt__past_dx, mh_y_ksads__suic__atmpt__past_dx, mh_y_ksads__suic__atmpt__intr__pres_dx, mh_y_ksads__suic__atmpt__abrt__pres_dx, mh_y_ksads__suic__atmpt__pres_dx, mh_p_ksads__suic__slfinj__nosi__pres_dx, mh_p_ksads__suic__slfinj__nosi__past_dx, mh_y_ksads__suic__slfinj__nosi__pres_dx, mh_y_ksads__suic__slfinj__nosi__past_dx, mh_p_ksads__bpd__bpd1__curdep__partrem_dx, mh_p_ksads__bpd__bpd1__rcnt__manicmix__pres_dx, mh_p_ksads__bpd__bpd1__curmanic__pres_dx, mh_p_ksads__bpd__bpd1__curdep__pres_dx, mh_y_ksads__bpd__bpd1__curmanic__pres_dx, mh_y_ksads__bpd__bpd1__curdep__pres_dx, mh_y_ksads__bpd__bpd1__rcnt__manic__pres_dx, mh_p_ksads__bpd__bpd1__curhypo__pres_dx, mh_p_ksads__bpd__bpd1__rcnt__dep__pres_dx, mh_p_ksads__bpd__bpd1__rcnt__manic__pres_dx, mh_y_ksads__bpd__bpd1__rcnt__dep__pres_dx, mh_y_ksads__bpd__bpd1__curhypo__pres_dx, mh_y_ksads__bpd__bpd1__rcnt__manicmix__pres_dx, mh_y_ksads__bpd__bpd1__curdep__partrem_dx, mh_p_ksads__bpd__bpd2__curhypo__pres_dx, mh_p_ksads__bpd__bpd2__rcnt__hypo__pres_dx, mh_p_ksads__bpd__bpd2__curdep__pres_dx, mh_p_ksads__bpd__bpd2__curdep__partrem_dx, mh_y_ksads__bpd__bpd2__curdep__pres_dx, mh_y_ksads__bpd__bpd2__curdep__partrem_dx, mh_y_ksads__bpd__bpd2__rcnt__hypo__pres_dx, mh_y_ksads__bpd__bpd2__curhypo__pres_dx, mh_p_ksads__bpd__bpd2__rcnt__hypomix__pres_dx, mh_y_ksads__bpd__bpd2__rcnt__hypomix__pres_dx, mh_p_ksads__bpd__bpd2__oth__mindur_dx, mh_p_ksads__bpd__oth__mindur_dx, mh_y_ksads__bpd__bpd2__oth__mindur_dx, mh_y_ksads__bpd__oth__mindur_dx, mh_p_ksads__bpd__unspec__pres_dx, mh_p_ksads__bpd__unspec__past_dx, mh_y_ksads__bpd__unspec__pres_dx, mh_y_ksads__bpd__unspec__past_dx, mh_p_ksads__dep__mdd__partrem_dx, mh_p_ksads__dep__mdd__past_dx, mh_p_ksads__dep__mdd__pres_dx, mh_p_ksads__dep__pdd__oth__pres_dx, mh_p_ksads__dep__pdd__partrem_dx, mh_p_ksads__dep__pdd__past_dx, mh_p_ksads__dep__pdd__pres_dx, mh_y_ksads__dep__mdd__partrem_dx, mh_y_ksads__dep__mdd__past_dx, mh_y_ksads__dep__mdd__pres_dx, mh_y_ksads__dep__pdd__oth__pres_dx, mh_y_ksads__dep__pdd__partrem_dx, mh_y_ksads__dep__pdd__past_dx, mh_y_ksads__dep__pdd__pres_dx, mh_p_cbcl__dsm__dep_tscore, mh_p_cbcl__dsm__dep_nm, mh_p_cbcl__dsm__anx_tscore, mh_p_cbcl__dsm__anx_nm, mh_p_cbcl__synd__attn_tscore, mh_p_cbcl__synd__attn_nm, mh_p_cbcl__synd__aggr_tscore, mh_p_cbcl__synd__aggr_nm, mh_p_gbi_sum))

#1.12 Turn all instances of empty, missing, 555, and 999 to NA; and 888 to 0 in KSADS columns
raw_data_trimmed <- raw_data_trimmed %>%
  mutate(across(starts_with("mh_") & contains("ksads"),
    ~ case_when(. == 888 ~ 0, . %in% c(555, 999, "") | is.na(.) ~ NA, TRUE ~ .)))

#1.2 Clean the Continuous CBCL Outcomes of Interest
raw_data_trimmed <- raw_data_trimmed %>% 
  mutate(
    
    #1.21 Remove any depression t scores created with missing values
    mh_p_cbcl__dsm__dep_tscore = if_else(mh_p_cbcl__dsm__dep_nm >= 1, NA_real_, mh_p_cbcl__dsm__dep_tscore),
    
    #1.22 Remove any anxiety t scores created with missing values
    mh_p_cbcl__dsm__anx_tscore = if_else(mh_p_cbcl__dsm__anx_nm >= 1, NA_real_, mh_p_cbcl__dsm__anx_tscore), 
    
    #1.23 Remove any attention t scores created with missing values
    mh_p_cbcl__synd__attn_tscore = if_else(mh_p_cbcl__synd__attn_nm >= 1, NA_real_, mh_p_cbcl__synd__attn_tscore),
    
    #1.24 Remove any aggression t scores created with missing values
    mh_p_cbcl__synd__aggr_tscore = if_else(mh_p_cbcl__synd__aggr_nm >= 1, NA_real_, mh_p_cbcl__synd__aggr_tscore))

#2. Preliminarily create relevant outcome variables of interest
#2.1 Define KSADS-COMP columns for each outcome
#2.1.1 Suicidal Ideation - passive (past or present; parent or youth report)
si_passive_vars <- c(
  "mh_p_ksads__suic__pass__past_dx",
  "mh_p_ksads__suic__pass__pres_dx",
  "mh_y_ksads__suic__pass__past_dx",
  "mh_y_ksads__suic__pass__pres_dx"
)

#2.1.2 Suicidal Ideation - active (all subtypes; past or present; parent or youth)
si_active_vars <- c(
  "mh_p_ksads__suic__actv__past_dx",
  "mh_p_ksads__suic__actv__mthd__past_dx",
  "mh_p_ksads__suic__actv__int__past_dx",
  "mh_p_ksads__suic__actv__plan__past_dx",
  "mh_p_ksads__suic__actv__pres_dx",
  "mh_p_ksads__suic__actv__mthd__pres_dx",
  "mh_p_ksads__suic__actv__int__pres_dx",
  "mh_p_ksads__suic__actv__plan__pres_dx",
  "mh_y_ksads__suic__actv__past_dx",
  "mh_y_ksads__suic__actv__mthd__past_dx",
  "mh_y_ksads__suic__actv__int__past_dx",
  "mh_y_ksads__suic__actv__plan__past_dx",
  "mh_y_ksads__suic__actv__pres_dx",
  "mh_y_ksads__suic__actv__mthd__pres_dx",
  "mh_y_ksads__suic__actv__int__pres_dx",
  "mh_y_ksads__suic__actv__plan__pres_dx"
)

#2.1.3 Suicide Attempt - interrupted, aborted, or completed (past or present; parent or youth)
sa_vars <- c(
  "mh_p_ksads__suic__atmpt__intr__past_dx",
  "mh_p_ksads__suic__atmpt__abrt__past_dx",
  "mh_p_ksads__suic__atmpt__past_dx",
  "mh_p_ksads__suic__atmpt__intr__pres_dx",
  "mh_p_ksads__suic__atmpt__abrt__pres_dx",
  "mh_p_ksads__suic__atmpt__pres_dx",
  "mh_y_ksads__suic__atmpt__intr__past_dx",
  "mh_y_ksads__suic__atmpt__abrt__past_dx",
  "mh_y_ksads__suic__atmpt__past_dx",
  "mh_y_ksads__suic__atmpt__intr__pres_dx",
  "mh_y_ksads__suic__atmpt__abrt__pres_dx",
  "mh_y_ksads__suic__atmpt__pres_dx"
)

#2.1.4 Non-Suicidal Self-Injury (NSSI; past or present; parent or youth)
nssi_vars <- c(
  "mh_p_ksads__suic__slfinj__nosi__pres_dx",
  "mh_p_ksads__suic__slfinj__nosi__past_dx",
  "mh_y_ksads__suic__slfinj__nosi__pres_dx",
  "mh_y_ksads__suic__slfinj__nosi__past_dx"
)

#2.1.5 Bipolar I Disorder - any current or recent past episode (parent or youth)
bd1_vars <- c(
  "mh_p_ksads__bpd__bpd1__curdep__partrem_dx",
  "mh_p_ksads__bpd__bpd1__rcnt__manicmix__pres_dx",
  "mh_p_ksads__bpd__bpd1__curmanic__pres_dx",
  "mh_p_ksads__bpd__bpd1__curdep__pres_dx",
  "mh_y_ksads__bpd__bpd1__curmanic__pres_dx",
  "mh_y_ksads__bpd__bpd1__curdep__pres_dx",
  "mh_y_ksads__bpd__bpd1__rcnt__manic__pres_dx",
  "mh_p_ksads__bpd__bpd1__curhypo__pres_dx",
  "mh_p_ksads__bpd__bpd1__rcnt__dep__pres_dx",
  "mh_p_ksads__bpd__bpd1__rcnt__manic__pres_dx",
  "mh_y_ksads__bpd__bpd1__rcnt__dep__pres_dx",
  "mh_y_ksads__bpd__bpd1__curhypo__pres_dx",
  "mh_y_ksads__bpd__bpd1__rcnt__manicmix__pres_dx",
  "mh_y_ksads__bpd__bpd1__curdep__partrem_dx"
)

#2.1.6 Bipolar II Disorder - any current or recent past hypomanic/depressive episode (parent or youth)
bd2_vars <- c(
  "mh_p_ksads__bpd__bpd2__curhypo__pres_dx",
  "mh_p_ksads__bpd__bpd2__rcnt__hypo__pres_dx",
  "mh_p_ksads__bpd__bpd2__curdep__pres_dx",
  "mh_p_ksads__bpd__bpd2__curdep__partrem_dx",
  "mh_y_ksads__bpd__bpd2__curdep__pres_dx",
  "mh_y_ksads__bpd__bpd2__curdep__partrem_dx",
  "mh_y_ksads__bpd__bpd2__rcnt__hypo__pres_dx",
  "mh_y_ksads__bpd__bpd2__curhypo__pres_dx",
  "mh_p_ksads__bpd__bpd2__rcnt__hypomix__pres_dx",
  "mh_y_ksads__bpd__bpd2__rcnt__hypomix__pres_dx"
)

#2.1.7 Any Bipolar Disorder - combine Bipolar I, II, OS & unspecified (parent or youth)
any_bsd_vars <- c(
  bd1_vars, bd2_vars,
  "mh_p_ksads__bpd__bpd2__oth__mindur_dx",
  "mh_p_ksads__bpd__oth__mindur_dx",
  "mh_y_ksads__bpd__bpd2__oth__mindur_dx",
  "mh_y_ksads__bpd__oth__mindur_dx",
  "mh_p_ksads__bpd__unspec__pres_dx",
  "mh_p_ksads__bpd__unspec__past_dx",
  "mh_y_ksads__bpd__unspec__pres_dx",
  "mh_y_ksads__bpd__unspec__past_dx"
)

# 2.1.8 Depression qualifiers for rescoring bipolar past mania/hypomania
dep_vars <- c(
  "mh_p_ksads__dep__mdd__partrem_dx",
  "mh_p_ksads__dep__mdd__past_dx",
  "mh_p_ksads__dep__mdd__pres_dx",
  "mh_y_ksads__dep__mdd__partrem_dx",
  "mh_y_ksads__dep__mdd__past_dx",
  "mh_y_ksads__dep__mdd__pres_dx",
  "mh_p_ksads__dep__pdd__oth__pres_dx",
  "mh_p_ksads__dep__pdd__partrem_dx",
  "mh_p_ksads__dep__pdd__past_dx",
  "mh_p_ksads__dep__pdd__pres_dx",
  "mh_y_ksads__dep__pdd__oth__pres_dx",
  "mh_y_ksads__dep__pdd__partrem_dx",
  "mh_y_ksads__dep__pdd__past_dx",
  "mh_y_ksads__dep__pdd__pres_dx"
)

#2.1.9 Bipolar I past mania vars for rescoring
bd1_past_mania_vars <- c(
  "mh_p_ksads__bpd__bpd1__rcnt__manic__pres_dx",
  "mh_y_ksads__bpd__bpd1__rcnt__manic__pres_dx"
)

#2.1.10 Bipolar II past hypomania vars for rescoring
bd2_past_mania_vars <- c(
  "mh_p_ksads__bpd__bpd2__rcnt__hypo__pres_dx",
  "mh_y_ksads__bpd__bpd2__rcnt__hypo__pres_dx"
)

#2.2 Create binary outcomes including any necessary validation steps
prelim_outcome_data <- raw_data_trimmed %>%
  mutate(
    
    #2.2.1 Suicidal ideation - passive
    si_passive = case_when(
      rowSums(dplyr::select(., all_of(si_passive_vars)) == 1, na.rm = TRUE) > 0 ~ 1,
      rowSums(!is.na(dplyr::select(., all_of(si_passive_vars)))) == 0 ~ NA_real_,
      TRUE ~ 0),
    
    #2.2.2 Suicidal ideation - active
    si_active = case_when(
      rowSums(dplyr::select(., all_of(si_active_vars))  == 1, na.rm = TRUE) > 0 ~ 1,
      rowSums(!is.na(dplyr::select(., all_of(si_active_vars)))) == 0 ~ NA_real_,
      TRUE ~ 0),
    
    #2.2.3 Suicide Attempt
    sa = case_when(
      rowSums(dplyr::select(., all_of(sa_vars)) == 1, na.rm = TRUE) > 0 ~ 1,
      rowSums(!is.na(dplyr::select(., all_of(sa_vars)))) == 0 ~ NA_real_,
      TRUE ~ 0),
    
    #2.2.4 Non-Suicidal Self-Injury (NSSI)
    nssi = case_when(
      rowSums(dplyr::select(., all_of(nssi_vars)) == 1, na.rm = TRUE) > 0 ~ 1,
      rowSums(!is.na(dplyr::select(., all_of(nssi_vars)))) == 0 ~ NA_real_,
      TRUE ~ 0),
    
    #2.2.5 Bipolar I Disorder
    bipolar_I = case_when(
      rowSums(dplyr::select(., all_of(bd1_vars)) == 1, na.rm = TRUE) > 0 ~ 1,
      rowSums(!is.na(dplyr::select(., all_of(bd1_vars)))) == 0 ~ NA_real_,
      TRUE ~ 0),
    
    #2.2.6 Bipolar II Disorder
    bipolar_II = case_when(
      rowSums(dplyr::select(., all_of(bd2_vars)) == 1, na.rm = TRUE) > 0 ~ 1,
      rowSums(!is.na(dplyr::select(., all_of(bd2_vars)))) == 0 ~ NA_real_,
      TRUE ~ 0),
    
    #2.2.7 Rescore Bipolar I at baseline & 2-year: past mania requires depression
    bipolar_I = case_when(
      session_id %in% c("ses-00A","ses-02A") &
        rowSums(dplyr::select(., all_of(bd1_past_mania_vars)) == 1, na.rm = TRUE) > 0 ~
          if_else(rowSums(dplyr::select(., all_of(dep_vars)) == 1, na.rm = TRUE) > 0, 1, 0),
      TRUE ~ bipolar_I),
    
    #2.2.8 Rescore Bipolar II at baseline & 2-year: past hypomania requires depression
    bipolar_II = case_when(
      session_id %in% c("ses-00A","ses-02A") &
        rowSums(dplyr::select(., all_of(bd2_past_mania_vars)) == 1, na.rm = TRUE) > 0 ~
          if_else(rowSums(dplyr::select(., all_of(dep_vars)) == 1, na.rm = TRUE) > 0, 1, 0),
      TRUE ~ bipolar_II),
    
    #2.2.9 Any Bipolar Spectrum Disorder
    any_bsd = case_when(
      rowSums(dplyr::select(., all_of(any_bsd_vars)) == 1, na.rm = TRUE) > 0 ~ 1,
      rowSums(!is.na(dplyr::select(., all_of(any_bsd_vars)))) == 0 ~ NA_real_,
      TRUE ~ 0)
  )

#2.3 Retain only the columns of interest to EDA of outcome data
prelim_outcome_data_trimmed <- prelim_outcome_data %>% 
  dplyr::select(c(participant_id, session_id, si_passive, si_active, sa, nssi, bipolar_I, bipolar_II, any_bsd, mh_p_cbcl__dsm__dep_tscore, mh_p_cbcl__dsm__anx_tscore, mh_p_cbcl__synd__attn_tscore, mh_p_cbcl__synd__aggr_tscore))

```

## 1. Integrity of the Data

The purpose of this section is to complete the following: 

| Step | Purpose |
|------|---------|
| **1 - Specify columns** | Identify the categorical diagnostic outcomes (`bipolar_I`, `bipolar_II`, etc.) and a small set of continuous CBCL scores whose completeness we want to inspect at the 4-year visit |
| **2 - Build helper functions** | Two small functions compute: **`n_non_na`** - how many rows have a usable value (non-missing, non-empty). **`percent_non_na`** - percent of the sample that is non-missing. **`range_or_unique`** - either the min-max range (continuous) or the set of unique values present (categorical) |
| **3 - Apply functions** | `lapply()` runs the helper across every categorical and continuous column, then collapses the results into one tidy data-frame |
| **4 - Display results** | A `kable()` table prints, showing for each variable: how many 4-year cases are usable, what proportion of the cohort that represents, and either the value range (CBCL T-scores) or the actual categories present (0/1 for diagnoses) |

Why we do this:

  - Quickly spot variables with excessive missingness (e.g., 70% complete) before they enter survival or mixed-effects models
  
  - Ensure CBCL scores are within valid T-score bounds (~20-80) and that binary outcomes only contain 0/1

```{r EDA 1, echo = FALSE, warning = FALSE}

## Exploratory Data Analysis ##

#1. Define the N, percent, and range of outcome variables of interest at the 4Y assessment timepoint
#1.1 Define the columns to analyze
#1.11 Categorical columns to analyze
categorical_columns <- c("bipolar_I", "bipolar_II", "any_bsd", "si_passive", "si_active", "sa", "nssi")

#1.12 Continuous columns to analyze
continuous_columns <- c("mh_p_cbcl__dsm__dep_tscore", "mh_p_cbcl__dsm__anx_tscore", "mh_p_cbcl__synd__attn_tscore", "mh_p_cbcl__synd__aggr_tscore")

#1.2 Create a function to compute EDA metrics for both categorical and continuous columns
get_missingness_metrics <- function(data, categorical_columns, continuous_columns) {
  
  #1.21 Helper function for categorical columns
  get_categorical_metrics <- function(column_name) {
    column_data <- data[[column_name]]
    n_non_na <- sum(!is.na(column_data) & column_data != "")
    percent_non_na <- (n_non_na / nrow(data)) * 100
    unique_values <- unique(column_data[!is.na(column_data) & column_data != ""])
    list(
      column = column_name,
      n_non_na = n_non_na,
      percent_non_na = percent_non_na,
      range_or_unique = unique_values
    )
  }
  
  #1.22 Helper function for continuous columns
  get_continuous_metrics <- function(column_name) {
    column_data <- data[[column_name]]
    n_non_na <- sum(!is.na(column_data) & column_data != "")
    percent_non_na <- (n_non_na / nrow(data)) * 100
    value_range <- range(column_data, na.rm = TRUE)
    list(
      column = column_name,
      n_non_na = n_non_na,
      percent_non_na = percent_non_na,
      range_or_unique = value_range
    )
  }
  
  #1.23 Process categorical columns
  categorical_metrics <- lapply(categorical_columns, get_categorical_metrics)
  
  #1.24 Process continuous columns
  continuous_metrics <- lapply(continuous_columns, get_continuous_metrics)
  
  #1.25 Combine results into a single list
  metrics <- c(categorical_metrics, continuous_metrics)
  
  #1.26 Convert to a dataframe for printing in output
  outcome_integrity_metrics <- do.call(rbind, lapply(metrics, function(x) {
    data.frame(
      column = x$column,
      n_non_na = x$n_non_na,
      percent_non_na = x$percent_non_na,
      range_or_unique = I(list(x$range_or_unique))
    )
  }))
  
  return(outcome_integrity_metrics)
}

#1.3 Apply the function to compute EDA metrics for both categorical and continuous columns to the outcome variable data
outcome_variable_integrity <- get_missingness_metrics(prelim_outcome_data_trimmed, categorical_columns, continuous_columns)

# Print the results
kable(outcome_variable_integrity, col.names = c("Variable", "N Non-Missing", "Percent Non-Missing", "Range/Unique Values"), digits = 3, row.names = FALSE) %>%
  kable_styling(bootstrap_options = c("striped","hover","condensed","responsive"))

```

## 2. Visually and Quantitatively Assess for any Outliers in the Data

The purpose of this section is to: 

| Step | Purpose |
|------|---------|
| **1 - Gather continuous outcomes** | Select the four CBCL T-score variables from the trimmed data and pivot them into long format (`Variable`, `Value`) |
| **2 - Draw faceted box-plots** | `ggplot2` generates a separate box-plot for each T-score, showing the median, IQR, whiskers (1.5×IQR), and any points beyond as potential outliers. Faceting keeps y-scales free so each distribution is shown in its own natural range |
| **3 - Visual inspection** | The resulting panel lets you quickly spot: extreme low/high T-scores (data entry issues?) skew/heavy-tail distributions that might influence clustering or regression |

Why we do this: 

  - Box-plots give an immediate visual flag for values that lie well outside the typical CBCL range (e.g., < 30 or > 100).
  
  - Faceting four plots in one view is an efficient QC step before deciding on transformations or winsorisation.  

```{r EDA 2, echo = FALSE, warning = FALSE}

## Exploratory Data Analysis ##

#2. Visually and Quantitatively Assess for any Outliers in the Data
#2.1 Create boxplots with outlier indicators for continuous variables in the dataset
#2.11 Filter only continuous variables
continuous_outcome_variables <- prelim_outcome_data_trimmed %>%
  dplyr::select(mh_p_cbcl__dsm__dep_tscore, mh_p_cbcl__dsm__anx_tscore, mh_p_cbcl__synd__attn_tscore, mh_p_cbcl__synd__aggr_tscore) %>%
  gather(key = "Variable", value = "Value")

#2.12 Create boxplot with facets for continuous variables
continuous_outcome_variables_boxplot <- ggplot(continuous_outcome_variables, aes(x = Variable, y = Value)) + 
  geom_boxplot(fill = "lightblue", color = "darkblue") + 
  facet_wrap(~ Variable, scales = "free") + 
  theme_minimal() + 
  theme(axis.text.x = element_blank(),
        strip.text = element_text(size = 6, face = "bold")) +
  labs(title = "Boxplots of Continuous Outcome Variables",
       y = "Values",
       x = "")

#2.13 Print the plot
print(continuous_outcome_variables_boxplot)

```

Based on the boxplots of the continuous (secondary) outcome variables, it does not appear as though any values are out of range or otherwise unexpected outliers. However, it does appear as if the data is not normally distributed, and this should be thoroughly assessed in subsequent steps.

## 3. Appropriateness of the Mean as a Measure of Central Tendency

While clustering methods used in this study do not require parametric assumptions, the secondary continuous outcome measures - `cbcl_scr_dsm5_depress_t`, `cbcl_scr_dsm5_anxdisord_t`, `cbcl_scr_syn_attention_t`, and `cbcl_scr_syn_aggressive_t` - will serve as dependent variables in statistical models that do. Therefore, examining kurtosis & skewness provides information about the asymmetry of these variable distributions, which may help identify variables with extreme outliers or long tails (and therefore any adaptations that should be made to our statistical analysis pipeline). 

Below, skewness & kurtosis values for the four secondary outcome measures are presented.

```{r EDA 3, echo = FALSE, warning = FALSE}

## Exploratory Data Analysis ##

#3.1 Calculate skewness & kurtosis for continuous variables
outcome_data_continuous_variables_skewness_kurtosis_table <- prelim_outcome_data_trimmed %>%
  dplyr::select(
    mh_p_cbcl__dsm__dep_tscore,
    mh_p_cbcl__dsm__anx_tscore,
    mh_p_cbcl__synd__attn_tscore,
    mh_p_cbcl__synd__aggr_tscore) %>%
  summarise(
    
  #3.1.1 Calculate skewness & kurtosis for each variable
    across(everything(), list(
      skewness = ~ skewness(.x, na.rm = TRUE),
      kurtosis = ~ kurtosis(.x, na.rm = TRUE)))) %>%
  
  #3.1.2 Reshape from wide to long format
  pivot_longer(
    cols = everything(),
    names_to = c("Variable", "Statistic"),
    names_pattern = "(.*)_(skewness|kurtosis)",
    values_to = "Value") %>%
  
  #3.1.3 Reshape back to have skewness and kurtosis as separate columns
  pivot_wider(names_from = Statistic, values_from = Value)

#3.2 Display the skewness & kurtosis table
kable(outcome_data_continuous_variables_skewness_kurtosis_table, caption = "Skewness & Kurtosis Values for Continuous Variables", digits = 2) %>%
  kable_styling(bootstrap_options = c("striped","hover","condensed","responsive"))

```

**All four outcomes show the typical CBCL pattern; strong positive skew and heavy tails, because most community youth score low while a small clinical subgroup stretches the right tail**

Implications for the longitudinal mixed-effects models: 

| Option | When to choose | Quick note |
|--------|----------------|------------|
| **Keep raw T-scores + robust / bootstrap SEs** | Large sample, focus on mean differences | Central-limit theorem handles skew; report Satterthwaite or bootstrap CIs |
| **Mild transform (√ or log)** | Residual QQ-plots still show heavy tail or heteroscedasticity | Transform, refit LMM, compare AIC/BIC |
| **Non-Gaussian GLMM (e.g., gamma)** | Skew remains problematic after transforms or transforms don't make sense | Fit with `glmmTMB` |

Suggested workflow for analyses: 

  1. Fit the base LMM on raw T-scores with robust SEs
  
  2. Inspect residual QQ-plots and variance-vs-fitted
  
  3. If diagnostics are poor, apply √/log transform and refit; record any change in inference
  
  4. Document choice and likely include GLMM sensitivity in the supplement anyway

## 4. Shape of Each Variables' Distribution

The shape of the distribution for each continuous variable and frequency distribution of each categorical variable is outlined below, both in terms of summary statistics derived from and a graphical histogram with density overlay of relevant data:

```{r EDA 4, echo = FALSE, warning = FALSE, fig.height=10, fig.width=10}

## Exploratory Data Analysis ##

#4. Create summary tables and visualizations for the distributions of categorical and continuous variables included as outcomes by timepoint
#4.1 Create a summary table for continuous and categorical variables by timepoint
summarize_data_by_timepoint <- function(data, continuous_cols, categorical_cols) {
  summary_list <- list()
  
  #4.1.1 Get unique timepoints
  timepoints <- unique(data$session_id)
  timepoints <- timepoints[!is.na(timepoints)]
  
  for (tp in timepoints) {
    tp_data <- data[data$session_id == tp, ]
    
    #4.1.2 Continuous variables summary by timepoint
    for (col in continuous_cols) {
      column_data <- tp_data[[col]]
      valid_values <- column_data[!is.na(column_data)]
      
      if (length(valid_values) > 0) {
        summary_list[[paste0(col, "_", tp)]] <- data.frame(
          Timepoint = tp,
          Variable = col,
          Type = "Continuous",
          N = length(valid_values),
          Mean = mean(valid_values, na.rm = TRUE),
          Median = median(valid_values, na.rm = TRUE),
          SD = sd(valid_values, na.rm = TRUE),
          Min = min(valid_values, na.rm = TRUE),
          Max = max(valid_values, na.rm = TRUE),
          Levels = NA,
          Frequencies = NA,
          stringsAsFactors = FALSE
        )
      }
    }
    
    #4.1.3 Categorical variables summary by timepoint
    for (col in categorical_cols) {
      column_data <- tp_data[[col]]
      freq_table <- table(column_data, useNA = "no")
      
      if (length(freq_table) > 0) {
        summary_list[[paste0(col, "_", tp)]] <- data.frame(
          Timepoint = tp,
          Variable = col,
          Type = "Categorical",
          N = sum(freq_table),
          Mean = NA,
          Median = NA,
          SD = NA,
          Min = NA,
          Max = NA,
          Levels = paste(names(freq_table), collapse = ", "),
          Frequencies = paste(freq_table, collapse = ", "),
          stringsAsFactors = FALSE
        )
      }
    }
  }
  
  do.call(rbind, summary_list)
}

#4.2 Generate the summary table by timepoint
summary_table_by_timepoint <- summarize_data_by_timepoint(prelim_outcome_data_trimmed, continuous_columns, categorical_columns)

#4.3 Print the summary table in the RMD
kable(summary_table_by_timepoint, caption = "Summary Statistics for Outcome Model Variables by Assessment Timepoint", row.names = FALSE) %>%
  kable_styling(bootstrap_options = c("striped","hover","condensed","responsive")) %>%
  column_spec(1, bold = TRUE) %>%
  pack_rows(index = table(summary_table_by_timepoint$Timepoint))

#4.4 Create plots visualizing distributions of variables by timepoint
#4.4.1 Prepare long data for continuous variables
cont_list <- map(continuous_columns, function(col) {
  prelim_outcome_data_trimmed %>%
    select(Value = !!sym(col), session_id) %>%
    filter(!is.na(Value)) %>%
    mutate(Type = "Continuous",
           Variable = col,
           Timepoint = session_id)
})

#4.4.2 Prepare long data for categorical variables
cat_list <- map(categorical_columns, function(col) {
  prelim_outcome_data_trimmed %>%
    select(Value = !!sym(col), session_id) %>%
    filter(!is.na(Value)) %>%
    mutate(Type      = "Categorical",
           Variable  = col,
           Timepoint = session_id)
})

#4.4.3 Combine continuous and categorical data into single frame
plot_data_by_timepoint <- bind_rows(cont_list, cat_list)

#4.4.4 Loop over each assessment timepoint to plot distributions
for (tp in sort(unique(plot_data_by_timepoint$Timepoint))) {

  #4.4.4.1 Filter data for current timepoint
  tp_data <- plot_data_by_timepoint %>%
    filter(Timepoint == tp)

  #4.4.4.2 Generate histogram + density for continuous variables
  cont_plot <- ggplot(tp_data %>% filter(Type == "Continuous"),
                      aes(x = Value)) +
    geom_histogram(aes(y = ..density..),
                   binwidth = 1,
                   fill = "steelblue",
                   alpha = 0.5,
                   color = "black") +
    geom_density(color = "firebrick",
                 size = 0.8,
                 adjust = 1.5) +
    facet_wrap(~ Variable, ncol = 3, scales = "free") +
    theme_minimal(base_size = 9) +
    labs(subtitle = paste("Timepoint:", tp),
         y = "Density",
         x = NULL) +
    theme(strip.text = element_text(size = 7),
          axis.text.x = element_text(angle = 30, hjust = 1, size = 6),
          plot.subtitle = element_text(hjust = 0.5, face = "bold"))

  #4.4.4.3 Generate bar plot for categorical variables
  cat_plot <- ggplot(tp_data %>% filter(Type == "Categorical"),
                     aes(x = factor(Value))) +
    geom_bar(fill = "skyblue",
             color = "black",
             alpha = 0.8) +
    geom_text(stat = "count",
              aes(label = ..count..),
              vjust = -0.3,
              size = 3) +
    facet_wrap(~ Variable, ncol = 3, scales = "free_y") +
    scale_x_discrete(labels = c("0" = "No", "1" = "Yes")) +
    scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
    theme_minimal(base_size = 9) +
    labs(y = "Count", x = NULL) +
    theme(strip.text = element_text(size = 7),
          axis.text.x = element_text(size = 6),
          plot.subtitle = element_text(hjust = 0.5, face = "bold"))

  #4.4.4.4 Stack continuous above categorical and print plots
  print(
    cont_plot / cat_plot +
    plot_annotation(title = "Distributions by Assessment Timepoint") &
    theme(plot.title = element_text(hjust = 0.5, face = "bold"))
  )
}

```

Distributions of continuous variables and rates of categorical variables by timepoint are shown above. While continuous variables exhibit noticeable skew & kurtosis, and the CBCL aggression problem scale results will need to be interpreted with caution/re-evaluated during modeling as described in section 3 above, no other problems are not noted herein. 

## 5. Distribution of Past-Only vs. Current Diagnoses by Timepoint

In this section, we split each bipolar diagnosis (and the combined “Any BSD” flag) into two mutually exclusive categories:  

  1. Current - youth who meet criteria for a manic/hypomanic or depressive episode at that assessment wave. 
  
  2. Past‐only - youth who endorse a recent past episode (mania/hypomania or “unspecified” bipolar) but do not currently meet criteria for a mood episode  

By tabulating both raw counts and percentages of “current” versus “past‐only” cases at each session, we can see how much of our baseline and follow-up prevalence is driven by active illness versus residual history. This helps contextualize any inflated “Any BSD” rates at early waves and ensures we understand whether “past‐only” cases drop out of the bipolar spectrum once they no longer meet full criteria.

```{r EDA 5, echo = FALSE, warning = FALSE}

## Distribution of Past-Only vs. Current Diagnoses by Timepoint ##

#5.1 Define vectors of raw KSADS columns for current vs. past mania/hypomania (these are subsets of the bd1_vars and bd2_vars already defined)
#5.1.1 Bipolar I “current” flags (any present manic or depressive episode)
bd1_current_vars <- c(
  "mh_p_ksads__bpd__bpd1__curdep__partrem_dx", 
  "mh_p_ksads__bpd__bpd1__curmanic__pres_dx",
  "mh_p_ksads__bpd__bpd1__curdep__pres_dx",
  "mh_y_ksads__bpd__bpd1__curmanic__pres_dx",
  "mh_y_ksads__bpd__bpd1__curdep__pres_dx",
  "mh_p_ksads__bpd__bpd1__curhypo__pres_dx",
  "mh_y_ksads__bpd__bpd1__curhypo__pres_dx",
  "mh_y_ksads__bpd__bpd1__curdep__partrem_dx"
)

#5.1.2 Bipolar I “past‐only” flags
bd1_pastonly_vars <- c(
  "mh_p_ksads__bpd__bpd1__rcnt__manicmix__pres_dx", 
  "mh_y_ksads__bpd__bpd1__rcnt__manic__pres_dx",
  "mh_p_ksads__bpd__bpd1__rcnt__dep__pres_dx",
  "mh_p_ksads__bpd__bpd1__rcnt__manic__pres_dx",
  "mh_y_ksads__bpd__bpd1__rcnt__dep__pres_dx",
  "mh_y_ksads__bpd__bpd1__rcnt__manicmix__pres_dx"
)

#5.1.3 Bipolar II “current” flags (any present hypomanic or depressive episode)
bd2_current_vars <- c(
  "mh_p_ksads__bpd__bpd2__curhypo__pres_dx",
  "mh_p_ksads__bpd__bpd2__curdep__pres_dx",
  "mh_p_ksads__bpd__bpd2__curdep__partrem_dx",
  "mh_y_ksads__bpd__bpd2__curdep__pres_dx",
  "mh_y_ksads__bpd__bpd2__curdep__partrem_dx",
  "mh_y_ksads__bpd__bpd2__curhypo__pres_dx"
)

#5.1.4 Bipolar II “past‐only” flags (recent past hypomania but no current)
bd2_pastonly_vars <- c(
  "mh_p_ksads__bpd__bpd2__rcnt__hypo__pres_dx",
  "mh_y_ksads__bpd__bpd2__rcnt__hypo__pres_dx",
  "mh_p_ksads__bpd__bpd2__rcnt__hypomix__pres_dx",
  "mh_y_ksads__bpd__bpd2__rcnt__hypomix__pres_dx"
)

#5.1.5.1 “Any BSD” current
anybsd_current_vars <- c(
  bd1_current_vars,
  bd2_current_vars,
  "mh_p_ksads__bpd__unspec__pres_dx",
  "mh_y_ksads__bpd__unspec__pres_dx",
  "mh_p_ksads__bpd__bpd2__oth__mindur_dx",
  "mh_p_ksads__bpd__oth__mindur_dx",
  "mh_y_ksads__bpd__bpd2__oth__mindur_dx",
  "mh_y_ksads__bpd__oth__mindur_dx"
)

#5.1.5.2 “Any BSD” past‐only
anybsd_pastonly_vars <- c(
  bd1_pastonly_vars,
  bd2_pastonly_vars,
  "mh_p_ksads__bpd__unspec__past_dx",
  "mh_y_ksads__bpd__unspec__past_dx"
)

# 5.1.6 Depression qualifiers for baseline & 2-yr rescoring
dep_vars <- c(
  "mh_p_ksads__dep__mdd__pres_dx", "mh_p_ksads__dep__mdd__past_dx",
  "mh_p_ksads__dep__mdd__partrem_dx",
  "mh_p_ksads__dep__pdd__pres_dx", "mh_p_ksads__dep__pdd__past_dx",
  "mh_p_ksads__dep__pdd__partrem_dx",
  "mh_y_ksads__dep__mdd__pres_dx", "mh_y_ksads__dep__mdd__past_dx",
  "mh_y_ksads__dep__mdd__partrem_dx",
  "mh_y_ksads__dep__pdd__pres_dx", "mh_y_ksads__dep__pdd__past_dx",
  "mh_y_ksads__dep__pdd__partrem_dx"
)

#5.2 Build current vs. past-only flags, with rescoring at ses-00A/02A
prelim_outcome_data2 <- prelim_outcome_data %>%
  mutate(
    
    #5.2.1 BD-I current
    bipolar_I_current = as.numeric(rowSums(dplyr::select(., all_of(bd1_current_vars)) == 1, na.rm=TRUE) > 0),

    #5.2.2 BD-I past-only: require depression at baseline & 2-yr
    bipolar_I_pastonly = case_when(
      rowSums(dplyr::select(., all_of(bd1_pastonly_vars)) == 1, na.rm=TRUE) > 0 &
        (!session_id %in% c("ses-00A","ses-02A") |
          rowSums(dplyr::select(., all_of(dep_vars)) == 1, na.rm=TRUE) > 0) ~ 1,
      TRUE ~ 0),

    #5.2.3 BD-II current
    bipolar_II_current = as.numeric(rowSums(select(., all_of(bd2_current_vars)) == 1, na.rm=TRUE) > 0),

    #5.2.4 BD-II past-only: require depression at baseline & 2-yr
    bipolar_II_pastonly = case_when(
      rowSums(dplyr::select(., all_of(bd2_pastonly_vars)) == 1, na.rm=TRUE) > 0 &
        (!session_id %in% c("ses-00A","ses-02A") |
          rowSums(dplyr::select(., all_of(dep_vars)) == 1, na.rm=TRUE) > 0) ~ 1,
      TRUE ~ 0),

    #5.2.5 Any BSD current
    any_bsd_current = as.numeric(rowSums(dplyr::select(., all_of(anybsd_current_vars)) == 1, na.rm=TRUE) > 0),

    #5.2.6 Any BSD past-only (no additional validation)
    any_bsd_pastonly = case_when(
      rowSums(dplyr::select(., all_of(anybsd_pastonly_vars)) == 1, na.rm=TRUE) > 0 &
        rowSums(dplyr::select(., all_of(anybsd_current_vars)) == 1, na.rm=TRUE) == 0 ~ 1,
      TRUE ~ 0)) %>%
  
  #5.2.7 Retain only columns of interest to analyses
  dplyr::select(participant_id, session_id,
         bipolar_I_current, bipolar_I_pastonly,
         bipolar_II_current, bipolar_II_pastonly,
         any_bsd_current, any_bsd_pastonly)

#5.3 Summarize counts & percentages by session
diagnosis_summary_by_time <- prelim_outcome_data2 %>%
  pivot_longer(
    cols = c(bipolar_I_current, bipolar_I_pastonly,
             bipolar_II_current, bipolar_II_pastonly,
             any_bsd_current, any_bsd_pastonly),
    names_to = c("Diagnosis","Timing"),
    names_pattern = "(bipolar_I|bipolar_II|any_bsd)_(current|pastonly)",
    values_to = "Flag") %>%
  group_by(session_id, Diagnosis, Timing) %>%
  summarize(
    N_flag = sum(Flag == 1, na.rm=TRUE),
    N_total = n(),
    Pct_flag = 100 * N_flag / N_total,
    .groups = "drop") %>%
  arrange(Diagnosis, Timing, session_id)

#5.4 Print summary table
kable(
  diagnosis_summary_by_time,
  col.names = c("Session","Diagnosis","Timing","N","Total N","Percent"),
  digits = c(0,0,0,0,0,1),
  caption = "Counts & Percentages of Current vs. Past-Only Diagnoses by Session") %>%
  kable_styling(full_width = FALSE)

```

In Section 5, we observe that "Any BSD" and individual bipolar diagnoses generally show their highest prevalence at baseline (ses-00A), with a significant portion initially classified as "past-only." Specifically, at baseline, 2.0% of youth (235/11,878) currently met criteria for Any BSD, and 13.2% (1,562/11,878) had a past-only BSD diagnosis - with that category primarily composed of other/unspecified bipolar cases. At the 2-year follow-up (ses-02A), current Any BSD prevalence slightly decreased to 1.1% (129/11,797), and past-only prevalence fell to 7.1% (841/11,797). By the 4-year follow-up (ses-04A) and later, past-only BSD prevalence remained very low (around 0.5%), while current BSD rates rose slightly to approximately 2.5-3.1%. This is likely due to the shift to KSADS 2.0 and better algorithmic/data collection procedures and not any actual patterns in the data. 

For Bipolar I, baseline prevalence was 0.7% current (81/11,878) and 0.2% past-only (28/11,878). At the 2-year follow-up, current prevalence decreased to 0.4% (46/11,797), while past-only remained at 0.2% (24/11,797). However, at subsequent assessments (ses-04A and ses-06A), Bipolar I prevalence increased, with current diagnoses at approximately 0.9-1.1% and past-only around 0.4-0.5%. This is (mostly) expected and likely reflects fairly good quality data. 

Bipolar II showed a consistently lower prevalence, with baseline current at 0.3% (38/11,878) and past-only at 0.1% (17/11,878). At the 2-year follow-up, current prevalence slightly dropped to 0.2% (24/11,797), while past-only slightly increased to 0.2% (24/11,797). Later waves (ses-04A and ses-06A) showed small increases in current diagnoses (0.4%) and consistently minimal past-only diagnoses (around 0.1%). This is also (mostly) expected and likely reflects fairly good quality data.

Overall, following the introduction of KSADS-COMP version 2.0 after ses-02A, there was a notable rise in current diagnoses for Any BSD and Bipolar I, and minimal past-only diagnoses. No diagnostic data were collected at odd-numbered follow-ups (ses-01A, ses-03A, ses-05A, ses-07A, ses-08A), thus resulting in zero counts at those waves.

## 6. Transitions: Who “Drops Out” vs. Who “Converts In” at Adjacent Timepoints

Here we examine longitudinal transitions in each bipolar diagnosis (and Any BSD) between consecutive assessment waves. Specifically, we identify:

  - Dropped Out: Youth who had the diagnosis at time _t_ but no longer meet criteria at time _t+1_
  
  - New On: Youth who did not have the diagnosis at time _t_ but do meet criteria at time _t+1_
  
  - Still Has / Still No: Youth who either continue to have or continue not to have the diagnosis across the two waves

By tabulating raw counts and percentages for each “From → To” pair (e.g., ses-00A → ses-02A), we can quantify how many cases resolve or emerge over time. This helps clarify the stability versus fluctuation of bipolar diagnoses (and combined BSD) across our follow-up waves

```{r EDA 6, echo = FALSE, warning = FALSE}

## Transitions: Who “Drops Out” vs. Who “Converts In” at Adjacent Timepoints ##

#6.1 Pull out only the binary diagnosis columns of interest (keep one “combined” flag per diagnosis)
diag_transitions <- prelim_outcome_data_trimmed %>%
  dplyr::select(participant_id, session_id, bipolar_I, bipolar_II, any_bsd)

#6.2 Pivot to wide format so that for each subject we have:
wide_diags <- diag_transitions %>%
  pivot_wider(
    names_from = session_id,
    values_from = c(bipolar_I, bipolar_II, any_bsd),
    names_sep = "_")

#6.3 Define a helper function to compute “drop‐outs” and “new‐ons” between two session columns
get_transition_counts <- function(df, diag_prefix, time1, time2) {
  col1 <- paste0(diag_prefix, "_", time1)
  col2 <- paste0(diag_prefix, "_", time2)
  
  #6.3.1 Treat NA as 0 (i.e., missing → no diagnosis)
  vect1 <- ifelse(is.na(df[[col1]]), 0, df[[col1]])
  vect2 <- ifelse(is.na(df[[col2]]), 0, df[[col2]])
  
  #6.3.2 Count transitions
  dropped_out <- sum(vect1 == 1 & vect2 == 0)
  still_has <- sum(vect1 == 1 & vect2 == 1)
  new_on <- sum(vect1 == 0 & vect2 == 1)
  still_no <- sum(vect1 == 0 & vect2 == 0)
  
  #6.3.3 Denominators for percentages
  n_with_at_time1 <- dropped_out + still_has
  n_without_at_time1 <- new_on + still_no 
  
  tibble(
    Diagnosis = diag_prefix,
    From = time1,
    To = time2,
    Dropped_Out = dropped_out,
    Still_Has = still_has,
    Pct_Dropped = 100 * dropped_out / max(n_with_at_time1, 1),
    New_On = new_on,
    Still_No = still_no,
    Pct_NewOn = 100 * new_on / (new_on + still_has)
  )
}

#6.4 Specify the ordered sessions you care about (make sure these match the levels in your data)
sessions <- c("ses-00A", "ses-02A", "ses-04A", "ses-06A") 

#6.5 Loop over each diagnosis prefix & each pair of consecutive sessions
all_transitions <- map_dfr(
  c("bipolar_I", "bipolar_II", "any_bsd"),
  function(diag_pref) {
    map_dfr(seq_len(length(sessions) - 1), function(i) {
      get_transition_counts(
        df = wide_diags,
        diag_prefix = diag_pref,
        time1 = sessions[i],
        time2 = sessions[i + 1])})
  }
)

#6.6 Print a transition summary table
kable(
  all_transitions %>%
    dplyr::select(
      Diagnosis, From, To,
      Dropped_Out, Pct_Dropped,
      New_On, Pct_NewOn,
      Still_Has, Still_No),
  col.names = c(
    "Diagnosis", "From", "To",
    "N Dropped", "% dropped (of Time1)",
    "N NewOn", "% new (of Time2)",
    "Still Has", "Still No"),
  digits = c(0, 0, 0, 0, 1, 0, 1, 0, 0),
  caption = "Transition Counts & Percentages Between Consecutive Sessions") %>%
  kable_styling(full_width = FALSE) 

```

Between each pair of available diagnostic waves, nearly all youth who met criteria at the earlier timepoint no longer met criteria at the next (“Dropped” → ~95% for Bipolar I/II, ~82-94% for Any BSD), and most of those diagnosed at the later timepoint were incident cases (“NewOn” → ~68-97% of those with a diagnosis at time *t+1* did not have it at time *t*). For example:
  
- Bipolar I:  
  
  - ses-00A→ses-02A: 100/105 cases (95.2%) dropped, 64/69 cases at ses-02A (92.8%) were new onset, only 5 remained stable.  

  - ses-02A→ses-04A: 65/69 (94.2%) dropped; 129/133 (97.0%) of ses-04A cases were new.  

  - ses-04A→ses-06A: 127/133 (95.5%) dropped; 134/140 (95.7%) of ses-06A cases were new.  

- Bipolar II:  
  
  - ses-00A→ses-02A: 31/32 (96.9%) dropped; 28/29 (96.6%) of ses-02A cases were new.  

  - ses-02A→ses-04A: 29/29 (100%) dropped; 45/45 (100%) of ses-04A cases were new (no one remained).  

  - ses-04A→ses-06A: 43/45 (95.6%) dropped; 47/49 (95.9%) of ses-06A cases were new.  

- Any BSD:  
  
  - ses-00A→ses-02A: 1 477/1 797 (82.2%) dropped; 650/970 (67.0%) of ses-02A cases were new, and 320 remained stable.  

  - ses-02A→ses-04A: 911/970 (93.9%) dropped; 235/294 (79.9%) of ses-04A cases were new, and 59 remained stable.  

  - ses-04A→ses-06A: 255/294 (86.7%) dropped; 306/345 (88.7%) of ses-06A cases were new, and 39 remained stable.  

In sum, very few youth with Bipolar I/II (or Any BSD) remained positive across waves: most earlier cases “dropped out,” and the vast majority of later cases were new onset. This underscores substantial diagnostic turnover rather than persistence across the available follow-ups. No diagnoses were collected in odd-numbered years, so transitions are shown only for even-year intervals

## 7. Transitions Between Diagnostic Categories

In this section, we create a multi‐state variable that encodes each youth’s bipolar spectrum diagnosis at each wave (No BSD, BD-I, BD-II, Other/Unspecified BSD), then compute the full transition matrix between consecutive waves. This allows us to quantify flows such as BD-I → BD-II, Other BSD → BD-I, etc., both in raw counts and as percentages of the “From” category

```{r EDA 7, echo = FALSE, warning = FALSE}

## Transitions Between Diagnostic Categories ##

#7.1 Assign a single diagnosis state factor for each subject/wave
#7.1.1 Define raw KSADS columns for Other/Unspecified BSD only
other_bsd_vars  <- c(
  "mh_p_ksads__bpd__bpd2__oth__mindur_dx",
  "mh_p_ksads__bpd__oth__mindur_dx",
  "mh_y_ksads__bpd__bpd2__oth__mindur_dx",
  "mh_y_ksads__bpd__oth__mindur_dx",
  "mh_p_ksads__bpd__unspec__pres_dx",
  "mh_p_ksads__bpd__unspec__past_dx",
  "mh_y_ksads__bpd__unspec__pres_dx",
  "mh_y_ksads__bpd__unspec__past_dx"
)

#7.1.2 Create diagnosis flags at each wave (more specific than "any BSD")
state_map <- function(df) {
  df %>%
    mutate(
      diag_state = case_when(
        
        #7.1.2.1 BD-I if any BD1 flag (current or past-only)
        bipolar_I_current == 1 | bipolar_I_pastonly == 1 ~ "BD1",
        
        #7.1.2.2 BD-II if any BD2 flag
        bipolar_II_current == 1 | bipolar_II_pastonly == 1 ~ "BD2",
        
        #7.1.2.3 OtherBSD only if an unspec flag and NO BD1/BD2
        rowSums(dplyr::select(., all_of(other_bsd_vars))  == 1, na.rm=TRUE) > 0 ~ "OtherBSD",
        
        #7.1.2.4 Otherwise no spectrum diagnosis
        TRUE ~ "NoBSD") %>%
      factor(levels = c("NoBSD","BD1","BD2","OtherBSD"))
    )
}

#7.1.3 Apply mapping to produce `prelim_states`
prelim_states <- prelim_outcome_data2 %>%
  left_join(prelim_outcome_data) %>% 
  filter(session_id == "ses-00A" | session_id == "ses-02A" | session_id == "ses-04A" | session_id == "ses-06A" | session_id == "ses-08A") %>% 
  state_map()

#7.2 Pivot data to one row per subject with diag_state_<session> columns
wide_states <- prelim_states %>%
  dplyr::select(participant_id, session_id, diag_state) %>%
  pivot_wider(
    names_from = session_id,
    values_from = diag_state,
    names_prefix = "diag_state_"
  )

#7.3 Create a function to compute transition counts and % for a given pair of sessions
get_state_matrix <- function(df, from_sess, to_sess) {
  tbl <- table(
    From = df[[paste0("diag_state_", from_sess)]],
    To = df[[paste0("diag_state_", to_sess)]])
  prop_tbl <- prop.table(tbl, margin = 1) * 100
  list(counts = tbl, props = prop_tbl)
}

#7.4 Create Transition Matrices for Each Pair of Waves
#7.4.1 Define your waves of interest
sessions <- c("ses-00A", "ses-02A", "ses-04A", "ses-06A", "ses-08A")

#7.4.2 Build a combined summary
transitions_summary <- map_dfr(seq_len(length(sessions) - 1), function(i) {
  from <- sessions[i]; to <- sessions[i + 1]
  mat <- get_state_matrix(wide_states, from, to)
  cnts <- as.matrix(mat$counts)
  prps <- round(as.matrix(mat$props), 1)
  tibble(
    Transition = paste0(from, "→", to),
    From = rownames(cnts),
    NoBSD = paste0(cnts[,"NoBSD"], " (", prps[,"NoBSD"],    "%)"),
    BD1 = paste0(cnts[,"BD1"], " (", prps[,"BD1"],      "%)"),
    BD2 = paste0(cnts[,"BD2"], " (", prps[,"BD2"],      "%)"),
    OtherBSD = paste0(cnts[,"OtherBSD"], " (", prps[,"OtherBSD"], "%)")
  )
})

#7.4.3 Render the table and group by timepoint
transitions_summary %>%
  dplyr::select(-Transition) %>%
  kable(
    col.names = c("From","NoBSD","BD1","BD2","OtherBSD"),
    align = "c",
    caption = "Transition Counts & Percentages Between Diagnostic States") %>%
  kable_styling(full_width = FALSE) %>%
  pack_rows(index = table(transitions_summary$Transition))

#7.5 Create a Sankey diagram displaying transitions between diagnostic categories across timepoints
#7.5.1 Store transition counts from each sequential timepoint to the next
links <- map_dfr(seq_len(length(sessions)-1), function(i) {
  from <- sessions[i]; to <- sessions[i+1]
  mat <- get_state_matrix(wide_states, from, to)$counts
  
  #7.5.1.1 Use expand.grid to create transition count dataframe
  df <- expand.grid(
    From = rownames(mat), 
    To = colnames(mat),
    stringsAsFactors = FALSE) %>%
    mutate(
      value = as.vector(mat),
      source = paste0(from, "_", From),
      target = paste0(to, "_", To)) %>%
    filter(value > 0) 
  return(df)
})

#7.5.2 Build nodes for Sankey
nodes <- data.frame(
  name = unique(c(links$source, links$target)),
  stringsAsFactors = FALSE
)

#7.5.3 Map source/target to node IDs
links <- links %>%
  mutate(
    IDsource = match(source, nodes$name) - 1,
    IDtarget = match(target, nodes$name) - 1
  )

#7.5.4 Plot Sankey diagram
sankeyNetwork(
  Links = links,
  Nodes = nodes,
  Source = "IDsource",
  Target = "IDtarget",
  Value = "value",
  NodeID = "name",
  fontSize = 8,
  nodeWidth = 30,
  sinksRight = FALSE
)

```

Across each consecutive assessment wave, most youth without a bipolar diagnosis remained stable (~97% NoBSD→NoBSD), though small numbers transitioned into BD-I, BD-II, or Other/Unspecified BSD categories (0.2-3.2%). 

Youth initially diagnosed with BD-I, BD-II, or Other BSD demonstrated high diagnostic instability. For example, between baseline and the 2-year follow-up, 87.5% of BD-I youth transitioned to NoBSD, with similarly high rates for BD-II (85.4%) and OtherBSD (90%). This pattern persisted across subsequent follow-ups, reflecting substantial flux rather than diagnostic persistence, particularly notable in transitions from diagnostic categories back to No BSD.

Another informative spot check is how many youth have any BSD at multiple timepoints. In brief, 2,346 (19.7%) participants have any BSD at any 1 of the timepoints; 458 (3.85%) participants have any BSD at 2 timepoints; 40 (0.33%) participants have any BSD at 3 timepoints; and 6 (0.05%) participants have any BSD at all 4 timepoints. 

## 8. Tiered Bipolar‐Spectrum Definitions & Their Stability

As forms of potential sensitivity analyses and to increase the specificity and sensitivity in our BSD cases, we define four “tiers” of increasing diagnostic stringency at each assessment timepoint to compare to just KSADS-COMP derived diagnoses:

  1. **Tier 1**: All four CBCL subscales (depression, anxiety, attention, aggression) ≥ 70 T-score  
  
  2. **Tier 2**: Tier 1 **+** GBI Mania total > 12 

  3. **Tier 3**: KSADS any BSD (current or past-only) **+** Tier 1  

  4. **Tier 4**: KSADS any BSD **+** Tier 1 **+** GBI Mania > 12  
  
We then count, for each youth, at how many of the four timepoints of interest (baseline, 2-year, 4-year, and 6-year follow-ups) they meet each tier, and display the distribution of those counts.

```{r EDA 8, echo = FALSE, warning = FALSE}

## Tiered Bipolar‐Spectrum Definitions & Their Stability ##

#8.1 Create tiered diagnosis flags
#8.11 Merge CBCL & GBI scores onto our diagnosis flags
tier_data <- prelim_outcome_data2 %>%
  left_join(
    prelim_outcome_data %>%
      dplyr::select(
        participant_id, session_id,
        mh_p_cbcl__dsm__dep_tscore,
        mh_p_cbcl__dsm__anx_tscore,
        mh_p_cbcl__synd__attn_tscore,
        mh_p_cbcl__synd__aggr_tscore,
        mh_p_gbi_sum),
    by = c("participant_id", "session_id")
  )

#8.12 Define tier flags (1/0) per subject row (i.e., at each timepoint)
tier_data <- tier_data %>%
  mutate(
    any_bsd_flag  = as.numeric(any_bsd_current==1 | any_bsd_pastonly==1),
    tier1 = as.numeric(
      mh_p_cbcl__dsm__dep_tscore >= 70 &
      mh_p_cbcl__dsm__anx_tscore >= 70 &
      mh_p_cbcl__synd__attn_tscore >= 70 &
      mh_p_cbcl__synd__aggr_tscore >= 70),
    tier2 = as.numeric(tier1 == 1 & mh_p_gbi_sum > 12),
    tier3 = as.numeric(any_bsd_flag == 1 & tier1 == 1),
    tier4 = as.numeric(any_bsd_flag == 1 & tier1 == 1 & mh_p_gbi_sum > 12)
  )

#8.2 Determine the prevalence of Each Tier by Timepoint
#8.2.1 Build a long table of tier flags
tier_long <- tier_data %>%
  dplyr::select(participant_id, session_id, tier1:tier4) %>%
  pivot_longer(
    cols = tier1:tier4,
    names_to = "Tier",
    values_to = "Flag"
  )

#8.2.2 Summarize N and percent per Tier × Timepoint
tier_prev <- tier_long %>%
  group_by(session_id, Tier) %>%
  summarise(
    N_flag = sum(Flag == 1, na.rm=TRUE),
    N_total = n_distinct(participant_id),
    Percent = 100 * N_flag / N_total,
    .groups = "drop") %>%
  arrange(Tier, session_id)

#8.2.3 Print occurrence rate table 
kable(
  tier_prev,
  col.names = c("Session", "Tier", "N Endorsed", "Total N", "% Endorsed"),
  digits = c(0, 0, 0, 0, 2),
  caption = "Prevalence of Each Tier by Wave") %>%
  kable_styling(full_width = FALSE) %>%
  pack_rows("Tier1 (CBCL BD Profile ≥ 70)", 1, length(unique(tier_prev$session_id))) %>%
  pack_rows("Tier2 (+GBI Mania > 12)", length(unique(tier_prev$session_id)) +
              1, 2 * length(unique(tier_prev$session_id))) %>%
  pack_rows("Tier3 (+KSADS Any BSD)",
            2 * length(unique(tier_prev$session_id)) + 1,
            3 * length(unique(tier_prev$session_id))) %>%
  pack_rows("Tier4 (All criteria)", 3 * length(unique(tier_prev$session_id)) +
              1, 4 * length(unique(tier_prev$session_id)))

#8.3 Determine the stability of each tier across timepoints
#8.3.1 Pivot wide: one column per tier × session
wide_tiers <- tier_long %>%
  pivot_wider(
    names_from  = c(Tier, session_id),
    values_from = Flag,
    names_sep   = "_"
  )

#8.3.2 Write a helper function for diagnostic transitions across time
get_transition_counts <- function(df, prefix, t1, t2) {
  c1 <- paste0(prefix, "_", t1)
  c2 <- paste0(prefix, "_", t2)
  v1 <- ifelse(is.na(df[[c1]]), 0, df[[c1]])
  v2 <- ifelse(is.na(df[[c2]]), 0, df[[c2]])
  dropped <- sum(v1==1 & v2==0)
  still <- sum(v1==1 & v2==1)
  newon <- sum(v1==0 & v2==1)
  still_no <- sum(v1==0 & v2==0)
  tibble(
    Tier = prefix,
    From = t1,
    To = t2,
    Dropped = dropped,
    Still = still,
    Pct_Drop  = 100 * dropped / max(dropped+still,1),
    NewOn = newon,
    StillNo = still_no,
    Pct_Newon = 100 * newon / max(newon+still,1)
  )
}

#8.3.3 Loop over tiers & session pairs counting diangostic transitions
sessions <- c("ses-00A","ses-02A","ses-04A","ses-06A")
all_tier_trans <- map_dfr(
  c("tier1","tier2","tier3","tier4"),
  ~ map_dfr(seq_len(length(sessions)-1), function(i) {
    get_transition_counts(wide_tiers, .x, sessions[i], sessions[i+1])})
)

#8.3.4 Print summary of diagnostic transitions across timepoints
kable(
  all_tier_trans,
  col.names = c("Tier","From","To",
                "N Dropped","N Still Has","% dropped",
                "N NewOnset","N Still No","% NewOnset"),
  digits = c(0,0,0,0,0,1,0,0,1),
  caption = "Tier Transition Counts & Percentages Between Waves") %>%
  kable_styling(full_width = FALSE)

#8.4 Build Sankey diagrams for each tier
#8.4.1 Create tier labels for plots
tier_labels <- c(
  tier1 = "Tier 1 - CBCL >=70 on All 4 Subscales",
  tier2 = "Tier 2 - Tier 1 + GBI Mania >12",
  tier3 = "Tier 3 - Any BSD + Tier 1",
  tier4 = "Tier 4 - Any BSD + Tier 1 + GBI Mania >12"
)

#8.4.2 Loop through each tier and create a sankey diagram for diagnostic transitions over time
widgets <- map(names(tier_labels), function(prefix) {
  
  #8.4.2.1 Build links
  links <- map_dfr(seq_len(length(sessions)-1), function(i) {
    t1 <- sessions[i]; t2 <- sessions[i+1]
    mat <- table(
      From = wide_tiers[[paste0(prefix, "_", t1)]],
      To = wide_tiers[[paste0(prefix, "_", t2)]]
    )
    expand.grid(From = rownames(mat), To = colnames(mat), 
                stringsAsFactors = FALSE) %>%
      mutate(
        value = as.vector(mat),
        source = paste0(t1, "_", From),
        target = paste0(t2, "_", To)) %>% 
      filter(value > 0)
  })
  
  #8.4.2.2 Build nodes
  nodes <- data.frame(name = unique(c(links$source, links$target)),
                      stringsAsFactors = FALSE)
  
  #8.4.2.3 Map links onto nodes
  links <- links %>%
    mutate(
      IDsource = match(source, nodes$name) - 1,
      IDtarget = match(target, nodes$name) - 1)
  
  #8.4.2.4 Build each sankey diagram
  sankey <- sankeyNetwork(
    Links = links,
    Nodes = nodes,
    Source = "IDsource",
    Target = "IDtarget",
    Value = "value",
    NodeID = "name",
    fontSize = 10,
    nodeWidth = 20,
    sinksRight= FALSE
  )
  
  #8.4.2.5 Return each sankey diagram
  tagList(
    tags$h4(tier_labels[prefix]),
    sankey
  )
})

#8.4.3 Render all sankey diagrams in the output
browsable(tagList(widgets))

```

Across the four even-year follow-up timepoints, the tiers are quite low in occurrence rate; and unsurprisingly, the stricter the definition, the rarer each tier is in ABCD.

Moreover, all four tiers show marked instability (ses-00 → 02 → 04 → 06):

  - Tier 1: ~83% of baseline cases drop by 2 yrs; new-onset cases each wave are ~75% of those diagnosed at the next wave, leaving only 4-5 participants (≤0.04 %) who persist from one wave to the next.

  - Tier 2: ≥ 88% of baseline cases remit by 2 yrs and ≥ 83% of the next-wave cases are incident.

  - Tier 3: 94% of baseline Tier 3 participants lose the tier by 2 yrs; every following Tier 3 case is incident (100% “new-onset”) and none persist across consecutive waves.

  - Tier 4: The strictest definition is almost entirely transient; every wave after baseline sees complete drop-out of prior Tier 4 cases and 100% of the few subsequent Tier 4 diagnoses are new relative to previous timepoints.

**Overall**, < 0.3% of the ABCD cohort ever meets Tier 1, < 0.15% meets Tier 2, and Tier 3/Tier 4 occur in only one or two dozen participants each wave. Persistence across multiple waves is exceptionally rare (no one meets Tier 3 or Tier 4 at two consecutive waves). To me, these findings reinforce that even with additional “validation” criteria, bipolar-spectrum indicators in ABCD are infrequent and highly unstable over time. Which is not to say that we shouldn't trust that our clinical classifications aren't useful or even that they don't represent bipolar in a way we wouldn't expect; just that they are limited by how much we trust their validity & reliability compared to clinician administered diagnoses
